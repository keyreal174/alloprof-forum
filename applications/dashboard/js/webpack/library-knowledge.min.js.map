{"version":3,"sources":["webpack://vanillaknowledge/./library/src/scripts/gdn.ts","webpack://vanillaknowledge/./library/src/scripts/application.tsx","webpack://vanillaknowledge/./library/src/scripts/apiv2.ts","webpack://vanillaknowledge/./library/src/scripts/state/reducerRegistry.ts","webpack://vanillaknowledge/./library/src/scripts/embeds.tsx","webpack://vanillaknowledge/./library/src/scripts/@types/api.ts","webpack://vanillaknowledge/./library/src/scripts/utility.ts","webpack://vanillaknowledge/./library/src/scripts/state/utility.ts"],"names":["gdn","window","meta","permissions","translations","__webpack_exports__","__webpack_require__","getMeta","key","defaultValue","_library_gdn__WEBPACK_IMPORTED_MODULE_2__","parts","split","haystack","parts_1","__values","parts_1_1","next","done","part","value","hasOwnProperty","t","str","defaultTranslation","substr","undefined","formatUrl","path","indexOf","assetUrl","_components","_mountComponents","parent","querySelectorAll","forEach","node","name","getAttribute","Component","toLowerCase","getComponent","react_dom__WEBPACK_IMPORTED_MODULE_1___default","a","render","react__WEBPACK_IMPORTED_MODULE_0___default","createElement","Object","_library_utility__WEBPACK_IMPORTED_MODULE_3__","_readyHandlers","onReady","callback","push","_executeReady","Promise","resolve","handlerPromises","map","handler","exec","all","then","document","readyState","addEventListener","onContent","makeProfileUrl","username","encodeURIComponent","api","axios__WEBPACK_IMPORTED_MODULE_2___default","create","baseURL","_library_application__WEBPACK_IMPORTED_MODULE_0__","headers","common","X-Requested-With","transformResponse","__spread","defaults","responseData","status","errors","length","_library_utility__WEBPACK_IMPORTED_MODULE_1__","paramsSerializer","params","qs__WEBPACK_IMPORTED_MODULE_3___default","stringify","indices","haveGot","wasReadyCalled","reducers","registerReducer","reducer","getReducers","__assign","FOCUS_CLASS","embedRenderers","embedComponents","registerEmbedRenderer","type","renderer","registerEmbedComponent","component","LoadStatus","d","sanitizeUrl","_debug","debug","newValue","log","_i","arguments","console","apply","logError","error","logWarning","warn","hashString","reduce","prevHash","currVal","charCodeAt","simplifyFraction","numerator","denominator","findGCD","b","gcd","shorthand","matchAtMention","subtext","shouldStartWithSpace","requireQuotesForWhitespace","lines","lastLine","nonExcludedCharacters","excludeWhiteSpace","excluded","regexStr","match","RegExp","rawMatch","IMAGE_REGEX","isFileImage","file","test","indexArrayByKey","array","object","array_1","array_1_1","item","SAFE_PROTOCOL_REGEX","url","_library_apiv2__WEBPACK_IMPORTED_MODULE_0__","createAction","payload","generateApiActionCreators","requestType","successType","errorType","dummyResponseType","dummyMetaType","request","createApiRequestAction","success","response","createApiSuccessAction","createApiErrorAction","apiThunk","endpoint","actionCreators","dispatch","catch","axiosError","data"],"mappings":"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","file":"applications/dashboard/js/webpack/library-knowledge.min.js?64afafeeb3314dace2a8","sourcesContent":["/**\n * A module to isolate meta data passed from the server into a single dependency.\n * This should always be used instead of accessing window.gdn directly.\n *\n * @copyright 2009-2018 Vanilla Forums Inc.\n * @license GPL-2.0-only\n */\n\ninterface IGdn {\n    meta: AnyObject;\n    permissions: AnyObject;\n    translations: AnyObject;\n    [key: string]: any;\n}\n\n/** The gdn object may be set in an inline script in the head of the document. */\nconst gdn = window.gdn || {};\n\nif (!(\"meta\" in gdn)) {\n    gdn.meta = {};\n}\n\nif (!(\"permissions\" in gdn)) {\n    gdn.permissions = {};\n}\n\nif (!(\"translations\" in gdn)) {\n    gdn.translations = {};\n}\n\nexport default gdn as IGdn;\n","/**\n * Application functions for interop between Components in different packages.\n *\n * @copyright 2009-2018 Vanilla Forums Inc.\n * @license GPL-2.0-only\n */\n\nimport React, { ComponentClass } from \"react\";\nimport ReactDOM from \"react-dom\";\nimport { RouteProps } from \"react-router-dom\";\nimport gdn from \"@library/gdn\";\nimport { PromiseOrNormalCallback, logError } from \"@library/utility\";\nimport isUrl from \"validator/lib/isURL\";\n\n/**\n * Get a piece of metadata passed from the server.\n *\n * @param key - The key to lookup.\n * @param defaultValue - A fallback value in case the key cannot be found.\n *\n * @returns Returns a meta value or the default value.\n */\nexport function getMeta(key: string, defaultValue?: any) {\n    if (!gdn.meta) {\n        return defaultValue;\n    }\n\n    const parts = key.split(\".\");\n    let haystack = gdn.meta;\n\n    for (const part of parts) {\n        if (!haystack.hasOwnProperty(part)) {\n            return defaultValue;\n        }\n        haystack = haystack[part];\n    }\n    return haystack;\n}\n\n/**\n * Set a piece of metadata. This will override what was passed from the server.\n *\n * @param key - The key to store under.\n * @param value - The value to set.\n */\nexport function setMeta(key: string, value: any) {\n    const parts = key.split(\".\");\n    const last = parts.pop();\n\n    if (!last) {\n        throw new Error(`Unable to set meta value ${key}. ${last} is not a valid object key.`);\n    }\n\n    let haystack = gdn.meta;\n\n    for (const part of parts) {\n        if (haystack[part] === null || typeof haystack[part] !== \"object\") {\n            haystack[part] = {};\n        }\n        haystack = haystack[part];\n    }\n    haystack[last] = value;\n}\n\n/**\n * Translate a string into the current locale.\n *\n * @param str - The string to translate.\n * @param defaultTranslation - The default translation to use.\n *\n * @returns Returns the translation or the default.\n */\nexport function translate(str: string, defaultTranslation?: string): string {\n    // Codes that begin with @ are considered literals.\n    if (str.substr(0, 1) === \"@\") {\n        return str.substr(1);\n    }\n\n    if (gdn.translations[str] !== undefined) {\n        return gdn.translations[str];\n    }\n\n    return defaultTranslation !== undefined ? defaultTranslation : str;\n}\n\n/**\n * The t function is an alias for translate.\n */\nexport const t = translate;\n\n/**\n * Determine if a string is an allowed URL.\n *\n * In the future this may be extended to check if we want to whitelist/blacklist various URLs.\n *\n * @param input - The string to check.\n */\nexport function isAllowedUrl(input: string): boolean {\n    // Options https://github.com/chriso/validator.js#validators\n    const options = {\n        protocols: [\"http\", \"https\"],\n        require_tld: true,\n        require_protocol: true,\n        require_host: true,\n        require_valid_protocol: true,\n        allow_trailing_dot: false,\n        allow_protocol_relative_urls: false,\n    };\n    return isUrl(input, options);\n}\n\n/**\n * Format a URL in the format passed from the controller.\n *\n * @param path - The path to format.\n *\n * @returns Returns a URL that can be used in the APP.\n */\nexport function formatUrl(path: string): string {\n    if (path.indexOf(\"//\") >= 0) {\n        return path;\n    } // this is an absolute path.\n\n    // The context paths that come down are expect to have no / at the end of them.\n    // Normally a domain like so: https://someforum.com\n    // When we don't have that we want to fallback to \"\" so that our path with a / can get passed.\n    const urlFormat = getMeta(\"context.basePath\", \"\");\n    return urlFormat + path;\n}\n\n/**\n * Create the URL of an asset of the site.\n *\n * @param path - The path to format.\n *\n * @returns Returns a URL that can be used for a static asset.\n */\nexport function assetUrl(path: string): string {\n    if (path.indexOf(\"//\") >= 0) {\n        return path;\n    } // this is an absolute path.\n\n    // The context paths that come down are expect to have no / at the end of them.\n    // Normally a domain like so: https://someforum.com\n    // When we don't have that we want to fallback to \"\" so that our path with a / can get passed.\n    const urlFormat = getMeta(\"context.assetPath\", \"\");\n    return urlFormat + path;\n}\n\n/**\n * @type {Object} The currently registered Components.\n * @private\n */\nconst _components = {};\n\n/**\n * Register a component in the Components registry.\n *\n * @param name The name of the component.\n * @param component The component to register.\n */\nexport function addComponent(name: string, component: ComponentClass) {\n    _components[name.toLowerCase()] = component;\n}\n\n/**\n * Test to see if a component has been registered.\n *\n * @param name The name of the component to test.\n * @returns Returns **true** if the component has been registered or **false** otherwise.\n */\nexport function componentExists(name: string): boolean {\n    return _components[name.toLowerCase()] !== undefined;\n}\n\n/**\n * Get a component from the component registry.\n *\n * @param name The name of the component.\n * @returns Returns the component or **undefined** if there is no registered component.\n */\nexport function getComponent(name: string): ComponentClass | undefined {\n    return _components[name.toLowerCase()];\n}\n\n/**\n * Mount all declared Components on the dom.\n *\n * The page signifies that an element contains a component with the `data-react=\"<Component>\"` attribute.\n *\n * @param parent - The parent element to search. This element is not included in the search.\n */\nexport function _mountComponents(parent: Element) {\n    const nodes = parent.querySelectorAll(\"[data-react]\").forEach(node => {\n        const name = node.getAttribute(\"data-react\") || \"\";\n        const Component = getComponent(name);\n\n        if (Component) {\n            ReactDOM.render(<Component />, node);\n        } else {\n            logError(\"Could not find component %s.\", name);\n        }\n    });\n}\n\n/**\n * @type {Array} The currently registered routes.\n * @private\n */\nconst _routes: any[] = [];\n\n/**\n * Register one or more routes to the app component.\n *\n * @param routes An array of routes to add.\n */\nexport function addRoutes(routes: Array<React.ReactElement<RouteProps>>) {\n    if (!Array.isArray(routes)) {\n        _routes.push(routes);\n    } else {\n        _routes.push(...routes);\n    }\n}\n\n/**\n * Get all of the currently registered routes.\n *\n * @returns Returns an array of routes.\n */\nexport function getRoutes(): Array<React.ReactElement<RouteProps>> {\n    return _routes;\n}\n\n/**\n * @type {Array}\n * @private\n */\nconst _readyHandlers: PromiseOrNormalCallback[] = [];\n\n/**\n * Register a callback that executes when the document and the core libraries are ready to use.\n *\n * @param callback - The function to call. This can return a Promise but doesn't have to.\n */\nexport function onReady(callback: PromiseOrNormalCallback) {\n    _readyHandlers.push(callback);\n}\n\n/**\n * Execute all of the registered events in order.\n *\n * @returns A Promise when the events have all fired.\n */\nexport function _executeReady(): Promise<any[]> {\n    return new Promise(resolve => {\n        const handlerPromises = _readyHandlers.map(handler => handler());\n        const exec = () => {\n            return Promise.all(handlerPromises).then(resolve);\n        };\n\n        if (document.readyState !== \"loading\") {\n            return exec();\n        } else {\n            document.addEventListener(\"DOMContentLoaded\", exec);\n        }\n    });\n}\n\n/**\n * Execute a callback when a piece of DOM content is ready to be operated on.\n *\n * This is similar to onReady() but also includes content that is added dynamically (ex. AJAX).\n * Note that this function is meant to bridge the non-react parts of the application with react.\n *\n * @param {function} callback - The callback to execute.\n */\nexport function onContent(callback) {\n    document.addEventListener(\"X-DOMContentReady\", callback);\n}\n\n/**\n * Make a URL to a user's profile.\n */\nexport function makeProfileUrl(username: string) {\n    const userPath = `/profile/${encodeURIComponent(username)}`;\n    return formatUrl(userPath);\n}\n","/**\n * Entrypoint for the APIv2 calls. Prepulates an axios instance with some config settings.\n *\n * @copyright 2009-2018 Vanilla Forums Inc.\n * @license GPL-2.0-only\n */\n\nimport { formatUrl, t } from \"@library/application\";\nimport { isFileImage, indexArrayByKey } from \"@library/utility\";\nimport axios from \"axios\";\nimport qs from \"qs\";\nimport { IEmbedData } from \"@library/embeds\";\nimport { IFieldError, LoadStatus, ILoadable } from \"@library/@types/api\";\n\nfunction fieldErrorTransformer(responseData) {\n    if (responseData.status >= 400 && responseData.errors && responseData.errors.length > 0) {\n        responseData.errors = indexArrayByKey(responseData.errors, \"field\");\n    }\n\n    return responseData;\n}\n\nconst api = axios.create({\n    baseURL: formatUrl(\"/api/v2/\"),\n    headers: {\n        common: {\n            \"X-Requested-With\": \"vanilla\",\n        },\n    },\n    transformResponse: [...axios.defaults.transformResponse, fieldErrorTransformer],\n    paramsSerializer: params => qs.stringify(params, { indices: false }),\n});\n\nexport default api;\n\n/**\n * Upload an image using Vanilla's API v2.\n *\n * @param file - The file to upload.\n *\n * @throws If the file given is not an image. You must check yourself first.\n */\nexport async function uploadImage(image: File): Promise<IEmbedData> {\n    if (!isFileImage(image)) {\n        throw new Error(\n            `Unable to upload an image of type ${image.type}. Supported formats included .gif, .jpg and .png`,\n        );\n    }\n\n    const data = new FormData();\n    data.append(\"file\", image, image.name);\n    data.append(\"type\", \"image\");\n\n    const result = await api.post(\"/media\", data);\n    result.data.type = \"image\";\n    return result.data;\n}\n\n/**\n * Extract a field specific error from an ILoadable if applicable.\n *\n * @param loadable - The loadable to extract from.\n * @param field - The field to extract.\n *\n * @returns an array of IFieldErrors if found or undefined.\n */\nexport function getFieldErrors(loadable: ILoadable<any>, field: string): IFieldError[] | undefined {\n    if (loadable.status === LoadStatus.ERROR || loadable.status === LoadStatus.LOADING) {\n        if (loadable.error && loadable.error.errors && loadable.error.errors[field]) {\n            return loadable.error.errors[field];\n        }\n    }\n}\n\n/**\n * Extract a global error message out of an ILoadable if applicable.\n *\n * @param loadable - The loadable to extract from.\n * @param validFields - Field to check for overriding fields errors from. A global error only shows if there are no valid field errors.\n *\n * @returns A global error message or an undefined.\n */\nexport function getGlobalErrorMessage(loadable: ILoadable<any>, validFields: string[]): string | undefined {\n    if (loadable.status === LoadStatus.ERROR || loadable.status === LoadStatus.LOADING) {\n        for (const field of validFields) {\n            if (getFieldErrors(loadable, field)) {\n                return;\n            }\n        }\n\n        if (loadable.error) {\n            return loadable.error.message || t(\"An error has occurred, please try again.\");\n        }\n    }\n}\n","/**\n * A reducer registry so that we can have dynamically loading reducers.\n *\n * @see http://nicolasgallagher.com/redux-modules-and-code-splitting/\n *\n * @copyright 2009-2018 Vanilla Forums Inc.\n * @license GPL-2.0-only\n */\n\nimport { onReady } from \"@library/application\";\nimport { logError } from \"@library/utility\";\nimport { Reducer, ReducersMapObject } from \"redux\";\n\nlet haveGot = false;\nlet wasReadyCalled = false;\nconst reducers = {};\n\nonReady(() => {\n    wasReadyCalled = true;\n});\n\nexport function registerReducer(name: string, reducer: Reducer) {\n    if (haveGot) {\n        logError(\"Cannot register reducer %s after reducers applied to the store.\", name);\n    } else {\n        reducers[name] = reducer;\n    }\n}\n\nexport function getReducers(): ReducersMapObject<any, any> {\n    haveGot = true;\n\n    if (!wasReadyCalled) {\n        logError(\"getReducers() was called before onReady\");\n    }\n\n    return {\n        ...reducers,\n    };\n}\n\n/**\n * @deprecated\n */\nconst reducerRegistry = {\n    register: registerReducer,\n    getReducers,\n};\n\nexport default reducerRegistry;\n","/**\n * Embed utility functions and types.\n * This file should have NO external dependencies other than javascript.\n *\n * @copyright 2009-2018 Vanilla Forums Inc.\n * @license GPL-2.0-only\n */\n\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport { IDiscussionEmbed, ICommentEmbed, IScrapeData } from \"@dashboard/@types/api\";\n\nexport const FOCUS_CLASS = \"embed-focusableElement\";\n\nexport type IQuoteEmbedData = IDiscussionEmbed | ICommentEmbed;\nexport type IEmbedData = IScrapeData;\n\nexport interface IEmbedElements {\n    root: HTMLElement;\n    content: HTMLElement;\n}\n\nexport type EmbedRenderer = (elements: IEmbedElements, data: IEmbedData, inEditor: boolean) => Promise<void>;\n\nexport interface IEmbedProps<T = IScrapeData> {\n    data: T;\n    inEditor: boolean;\n    onRenderComplete: () => void;\n}\n\nconst embedRenderers: {\n    [type: string]: EmbedRenderer;\n} = {};\nconst embedComponents: {\n    [type: string]: React.ComponentClass<IEmbedProps>;\n} = {};\n\n/**\n * Get all of the registered embed types.\n */\nexport function getEditorEmbedTypes() {\n    return Object.keys(embedRenderers);\n}\n\n/**\n * Register an embed rendering function.\n */\nexport function registerEmbedRenderer(type: string, renderer: EmbedRenderer) {\n    embedRenderers[type] = renderer;\n}\n\n/**\n * Register an embed rendering function.\n */\nexport function registerEmbedComponent(type: string, component: React.ComponentClass<IEmbedProps>) {\n    embedComponents[type] = component;\n}\n\n/**\n * Render an embed into a DOM node based on it's type.\n */\nexport function renderEmbed(elements: IEmbedElements, data: IEmbedData, inEditor = true): Promise<void> {\n    return new Promise((resolve, reject) => {\n        if (!data.type) {\n            throw new Error(\"The embed type was not provided.\");\n        }\n\n        if (data.type === \"link\") {\n            elements.root.classList.add(\"embedText\");\n            elements.content.classList.add(\"embedText-content\");\n            elements.content.classList.add(\"embedLink-content\");\n        }\n\n        if (data.type === \"quote\") {\n            elements.root.classList.add(\"embedText\");\n            elements.content.classList.add(\"embedText-content\");\n            elements.content.classList.add(\"embedQuote-content\");\n        }\n\n        const renderer = data.type && embedRenderers[data.type];\n        const Component = data.type && embedComponents[data.type];\n\n        if (renderer) {\n            return renderer(elements, data, inEditor);\n        } else if (Component) {\n            ReactDOM.render(\n                <Component data={data as IScrapeData} inEditor={inEditor} onRenderComplete={resolve} />,\n                elements.content,\n            );\n        } else {\n            throw new Error(\"Could not find a renderer for the embed type - \" + data.type);\n        }\n    });\n}\n","/**\n * @copyright 2009-2018 Vanilla Forums Inc.\n * @license GPL-2.0-only\n */\n\nexport const enum LoadStatus {\n    PENDING = \"PENDING\",\n    LOADING = \"LOADING\",\n    SUCCESS = \"SUCCESS\",\n    ERROR = \"ERROR\",\n}\n\ninterface IPendingValue {\n    status: LoadStatus.PENDING;\n}\n\ninterface ILoadingValue<T> {\n    status: LoadStatus.LOADING;\n    data?: T;\n    error?: IApiError;\n}\n\ninterface ISuccessValue<T> {\n    status: LoadStatus.SUCCESS;\n    data: T;\n    error?: undefined;\n}\n\ninterface IErrorValue<T> {\n    status: LoadStatus.ERROR;\n    error: IApiError;\n    data?: T;\n}\n\nexport type ILoadable<T> = IPendingValue | ILoadingValue<T> | ISuccessValue<T> | IErrorValue<T>;\n\nexport interface IApiResponse<DataType = any> {\n    data: DataType;\n    status: number;\n    headers: any;\n}\n\nexport interface IFieldError {\n    message: string; // translated message\n    code: string; // translation code\n    field: string;\n    status?: number; // HTTP status\n}\n\nexport interface IApiError {\n    message: string;\n    status: number;\n    errors?: {\n        [key: string]: IFieldError[];\n    };\n}\n","/**\n * General utility functions.\n * This file should have NO external dependencies other than javascript.\n *\n * @copyright 2009-2018 Vanilla Forums Inc.\n * @license GPL-2.0-only\n */\n\n/**\n * @type {boolean} The current debug setting.\n * @private\n */\nlet _debug = false;\n\n/**\n * Get or set the debug flag.\n *\n * @param newValue - The new value of debug.\n * @returns the current debug setting.\n */\nexport function debug(newValue?: boolean): boolean {\n    if (newValue !== undefined) {\n        _debug = newValue;\n    }\n\n    return _debug;\n}\n\ntype NormalCallback = (...args: any[]) => any;\ntype PromiseCallback = (...args: any[]) => Promise<any>;\n\nexport type PromiseOrNormalCallback = NormalCallback | PromiseCallback;\n\n/**\n * Resolve an array of functions that return promises sequentially.\n *\n * @param promiseFunctions - The functions to execute.\n *\n * @returns An array of all results in sequential order.\n *\n * @example\n * const urls = ['/url1', '/url2', '/url3']\n * const functions = urls.map(url => () => fetch(url))\n * resolvePromisesSequentially(funcs)\n *   .then(console.log)\n *   .catch(console.error)\n */\nexport function resolvePromisesSequentially(promiseFunctions: PromiseOrNormalCallback[]): Promise<any[]> {\n    if (!Array.isArray(promiseFunctions)) {\n        throw new Error(\"First argument needs to be an array of Promises\");\n    }\n\n    return new Promise((resolve, reject) => {\n        let count = 0;\n        let results = [];\n\n        function iterationFunction(previousPromise, currentPromise) {\n            return previousPromise\n                .then(result => {\n                    if (count++ !== 0) {\n                        results = results.concat(result);\n                    }\n\n                    return currentPromise(result, results, count);\n                })\n                .catch(err => reject(err));\n        }\n\n        promiseFunctions = promiseFunctions.concat(() => Promise.resolve());\n\n        promiseFunctions.reduce(iterationFunction, Promise.resolve(false)).then(() => {\n            resolve(results);\n        });\n    });\n}\n\n/**\n * Log something to console.\n *\n * This only prints in debug mode.\n *\n * @param value - The value to log.\n */\nexport function log(...value: any[]) {\n    if (_debug) {\n        // tslint:disable-next-line:no-console\n        console.log(...value);\n    }\n}\n\n/**\n * Log an error to console.\n *\n * @param value - The value to log.\n */\nexport function logError(...value: any[]) {\n    // tslint:disable-next-line:no-console\n    console.error(...value);\n}\n\n/**\n * Log a warning to console.\n *\n * @param value - The value to log.\n */\nexport function logWarning(...value: any[]) {\n    // tslint:disable-next-line:no-console\n    console.warn(...value);\n}\n\n/**\n * A simple, fast method of hashing a string. Similar to Java's hash function.\n * https://stackoverflow.com/a/7616484/1486603\n *\n * @param str - The string to hash.\n *\n * @returns The hash code returned.\n */\nexport function hashString(str: string): number {\n    function hashReduce(prevHash, currVal) {\n        // tslint:disable-next-line:no-bitwise\n        return (prevHash << 5) - prevHash + currVal.charCodeAt(0);\n    }\n    return str.split(\"\").reduce(hashReduce, 0);\n}\n\n/**\n * Split a string in multiple pieces similar to String.prototype.split but ignore most acccent characters.\n *\n * This will still return pieces with accents.\n *\n * @param toSplit The string to split.\n * @param splitWith The string to split with.\n */\nexport function splitStringLoosely(toSplit: string, splitWith: string): string[] {\n    const normalizedName = toSplit.normalize(\"NFD\").replace(/[\\u0300-\\u036f]/g, \"\");\n    const normalizedSplitTerm = splitWith.normalize(\"NFD\").replace(/[\\u0300-\\u036f]/g, \"\");\n    const normalizedPieces = normalizedName.split(new RegExp(`(${normalizedSplitTerm})`, \"i\"));\n\n    let charactersUsed = 0;\n    return normalizedPieces.map(piece => {\n        const start = charactersUsed;\n        charactersUsed += piece.length;\n        return toSplit.substring(start, charactersUsed);\n    });\n}\n\ninterface IClass {\n    new (): any;\n}\n\nexport function isInstanceOfOneOf(needle: any, haystack: IClass[]) {\n    for (const classItem of haystack) {\n        if (needle instanceof classItem) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\nexport function simplifyFraction(numerator: number, denominator: number) {\n    const findGCD = (a, b) => {\n        return b ? findGCD(b, a % b) : a;\n    };\n    const gcd = findGCD(numerator, denominator);\n\n    numerator = numerator / gcd;\n    denominator = denominator / gcd;\n\n    return {\n        numerator,\n        denominator,\n        shorthand: denominator + \":\" + numerator,\n    };\n}\n\ninterface IMentionMatch {\n    match: string;\n    rawMatch: string;\n}\n\n/**\n * Custom matching to allow quotation marks in the matching string as well as spaces.\n * Spaces make things more complicated.\n *\n * @param subtext - The string to be tested.\n * @param shouldStartWithSpace - Should the pattern include a test for a whitespace prefix?\n * @returns Matching string if successful.  Null on failure to match.\n */\nexport function matchAtMention(\n    subtext: string,\n    shouldStartWithSpace: boolean = false,\n    requireQuotesForWhitespace: boolean = true,\n): IMentionMatch | null {\n    // Split the string at the lines to allow for a simpler regex.\n    const lines = subtext.split(\"\\n\");\n    const lastLine = lines[lines.length - 1];\n\n    // If you change this you MUST change the regex in src/scripts/__tests__/legacy.test.js !!!\n    /**\n     * Put together the non-excluded characters.\n     *\n     * @param {boolean} excludeWhiteSpace - Whether or not to exclude whitespace characters.\n     *\n     * @returns {string} A Regex string.\n     */\n    function nonExcludedCharacters(excludeWhiteSpace) {\n        let excluded =\n            \"[^\" +\n            '\"' + // Quote character\n            \"\\\\u0000-\\\\u001f\\\\u007f-\\\\u009f\" + // Control characters\n            \"\\\\u2028\"; // Line terminator\n\n        if (excludeWhiteSpace) {\n            excluded += \"\\\\s\";\n        }\n\n        excluded += \"]\";\n        return excluded;\n    }\n\n    let regexStr =\n        \"@\" + // @ Symbol triggers the match\n        \"(\" +\n        // One or more non-greedy characters that aren't excluded. Whitespace is allowed, but a starting quote is required.\n        '\"(' +\n        nonExcludedCharacters(false) +\n        '+?)\"?' +\n        \"|\" + // Or\n        // One or more non-greedy characters that aren't exluded. Whitespace may be excluded.\n        \"(\" +\n        nonExcludedCharacters(requireQuotesForWhitespace) +\n        '+?)\"?' +\n        \")\" +\n        \"(?:\\\\n|$)\"; // Newline terminates.\n\n    // Determined by at.who library\n    if (shouldStartWithSpace) {\n        regexStr = \"(?:^|\\\\s)\" + regexStr;\n    }\n    const regex = new RegExp(regexStr, \"gi\");\n    const match = regex.exec(lastLine);\n    if (match) {\n        return {\n            rawMatch: match[0],\n            match: match[2] || match[1], // Return either of the matching groups (quoted or unquoted).\n        };\n    }\n\n    // No match\n    return null;\n}\n\n/** This should mirror extensions allowed in Vanilla\\ImageResizer.php */\nconst IMAGE_REGEX = /^image\\/(gif|jpe?g|png)/i;\n\n/**\n * A filter for use with [].filter\n *\n * Matches only image image type files.\n * @private\n *\n * @param file - A File object.\n * @see https://developer.mozilla.org/en-US/docs/Web/API/File\n *\n * @returns Whether or not the file is an acceptable image\n */\nexport function isFileImage(file: File): boolean {\n    if (IMAGE_REGEX.test(file.type)) {\n        return true;\n    }\n\n    log(\"Filtered out non-image file: \", file.name);\n    return false;\n}\n\nexport function capitalizeFirstLetter(str: string): string {\n    return str.charAt(0).toUpperCase() + str.slice(1);\n}\n\n/**\n * Transform an array of objects and an map of objets with a given key.\n *\n * Objects that do not contain the given key are dropped.\n *\n * @param array The array to go through.\n * @param key The key to lookup.\n */\nexport function indexArrayByKey<T extends object>(\n    array: T[],\n    key: string,\n): {\n    [key: string]: T;\n} {\n    const object = {};\n    for (const item of array) {\n        if (key in item) {\n            if (!(item[key] in object)) {\n                object[item[key]] = [];\n            }\n            object[item[key]].push(item);\n        }\n    }\n    return object;\n}\n\nconst SAFE_PROTOCOL_REGEX = /^(http:\\/\\/|https:\\/\\/|tel:|mailto:\\/\\/)/;\n\n/**\n * Sanitize a URL to ensure that it matches a whitelist of approved url schemes. If the url does not match one of these schemes, prepend `unsafe:` before it.\n *\n * Allowed protocols\n * - \"http://\",\n * - \"https://\",\n * - \"tel:\",\n * - \"mailto://\",\n *\n * @param url The url to sanitize.\n */\nexport function sanitizeUrl(url: string) {\n    if (url.match(SAFE_PROTOCOL_REGEX)) {\n        return url;\n    } else {\n        return \"unsafe:\" + url;\n    }\n}\n","/**\n * State utility functions.\n *\n * @copyright 2009-2018 Vanilla Forums Inc.\n * @license GPL-2.0-only\n */\n\nimport { IApiResponse, IApiError } from \"@library/@types/api\";\nimport apiv2 from \"@library/apiv2\";\nimport { AxiosResponse, AxiosError } from \"axios\";\n\n// Utility to pull a group of action types out of an actions object\nexport type ActionsUnion<A extends IActionCreatorsMapObject> = ReturnType<A[keyof A]>;\n\n// Utility to create a generic action action.\n\n/**\n * Utility to create an action with our a without a payload of a given type.\n * The action generated can have its type narrowed in a reducer switch statement if the type T matches.\n *\n * @see ActionsUnion\n *\n * @param type The action type.\n * @param payload The payload data.\n */\nexport function createAction<ActionType extends string>(type: ActionType): IAction<ActionType>;\nexport function createAction<ActionType extends string, Payload>(\n    type: ActionType,\n    payload: Payload,\n): IActionWithPayload<ActionType, Payload>;\nexport function createAction<ActionType extends string, Payload>(type: ActionType, payload?: Payload) {\n    return payload === undefined ? { type } : { type, payload };\n}\n\n/**\n * Create request, response, and error action creators.\n *\n * The dummy types are needed because typescript currently requires all generic types to be specified or all to be inferred. They cannot currently be mixed.\n *\n * @see https://github.com/Microsoft/TypeScript/issues/10571#issuecomment-345402872\n *\n * @param requestType The string for the request type. This should be a unique constant.\n * @param successType The string for the success type. This should be a unique constant.\n * @param errorType The string for the error type. This should be a unique constant.\n * @param dummyResponseType A placeholder to infer the type of the response. This isn't used for anything other than inferring a type.\n * @param dummyMetaType A placeholder to infer the type of the meta. This isn't used for anything other than inferringa  type.\n *\n * @example\n *\n * ```\n * const GET_THING_REQUEST = \"GET_THING_REQUEST\";\n * const GET_THING_SUCCESS = \"GET_THING_SUCCESS\";\n * const GET_THING_ERROR = \"GET_THING_ERROR\";\n * interface IThing { thing: string }\n * interface IThingOptions { page?: number }\n *\n * generateApiActionCreators(GET_THING_REQUEST, GET_THING_SUCCESS, GET_THING_ERROR, {} as IThing, {} as IThingOptions);\n * ```\n */\nexport function generateApiActionCreators<\n    RequestActionType extends string,\n    SuccessActionType extends string,\n    ErrorActionType extends string,\n    ResponseDataType,\n    Meta = any\n>(\n    requestType: RequestActionType,\n    successType: SuccessActionType,\n    errorType: ErrorActionType,\n    dummyResponseType?: ResponseDataType,\n    dummyMetaType?: Meta,\n): {\n    request: (meta?: Meta) => IApiAction<RequestActionType, Meta>;\n    success: (\n        payload: IApiResponse<ResponseDataType>,\n        meta?: Meta,\n    ) => IApiSuccessAction<SuccessActionType, Meta, ResponseDataType>;\n    error: (error: IApiError, meta?: Meta) => IApiErrorAction<ErrorActionType, Meta>;\n} {\n    return {\n        request: (meta: Meta) => createApiRequestAction(requestType, meta),\n        success: (response: IApiResponse<ResponseDataType>, meta: Meta) =>\n            createApiSuccessAction(successType, meta, response),\n        error: (error: IApiError, meta: Meta) => createApiErrorAction(errorType, meta, error),\n    };\n}\n\ntype GeneratedActionCreators = ReturnType<typeof generateApiActionCreators>;\n\n// Thunk types\ntype RequestType = \"get\" | \"post\" | \"put\" | \"delete\" | \"patch\";\nexport function apiThunk(\n    requestType: RequestType,\n    endpoint: string,\n    actionCreators: GeneratedActionCreators,\n    params: any,\n) {\n    return dispatch => {\n        dispatch(actionCreators.request(params));\n        apiv2[requestType as any](endpoint, params)\n            .then((response: AxiosResponse) => {\n                dispatch(actionCreators.success(response, params));\n            })\n            .catch((axiosError: AxiosError) => {\n                const error = axiosError.response ? axiosError.response.data : (axiosError as any);\n                dispatch(actionCreators.error(error));\n            });\n    };\n}\n\n// Action interfaces\nexport interface IAction<T extends string> {\n    type: T;\n}\n\nexport interface IActionWithPayload<T extends string, P> extends IAction<T> {\n    payload: P;\n}\n\nexport interface IActionCreator<T extends string> {\n    (): IAction<T>;\n}\n\ntype FunctionType = (...args: any[]) => any;\ninterface IActionCreatorsMapObject {\n    [actionCreator: string]: FunctionType;\n}\n\n// API Action interfaces\ninterface IApiAction<ActionType, Meta> {\n    type: ActionType;\n    meta: Meta;\n}\n\ninterface IApiErrorAction<ActionType, Meta> extends IApiAction<ActionType, Meta> {\n    payload: IApiError;\n}\n\ninterface IApiSuccessAction<ActionType, Meta, ResponseDataType> extends IApiAction<ActionType, Meta> {\n    payload: IApiResponse<ResponseDataType>;\n}\n\n/**\n * Create an API request action. For use in createApiActions().\n *\n * @param type The action's type.\n * @param meta The type of the meta for the action.\n */\nfunction createApiRequestAction<ActionType extends string, Meta>(\n    type: ActionType,\n    meta: Meta,\n): IApiAction<ActionType, Meta> {\n    return {\n        type,\n        meta,\n    };\n}\n\n/**\n * Create an API error action. For use in createApiActions().\n *\n * @param type The action's type.\n * @param meta The type of the meta for the action.\n * @param error An API error.\n */\nfunction createApiErrorAction<ActionType extends string, Meta>(\n    type: ActionType,\n    meta: Meta,\n    error: IApiError,\n): IApiErrorAction<ActionType, Meta> {\n    return {\n        type,\n        meta,\n        payload: error,\n    };\n}\n\n/**\n * Create an API success action. For use in createApiActions().\n *\n * @param type The action's type.\n * @param meta The type of the meta for the action.\n * @param payload The shape of the IApiResponse data.\n */\nfunction createApiSuccessAction<ActionType extends string, Meta, ResponseDataType>(\n    type: ActionType,\n    meta: Meta,\n    payload: IApiResponse<ResponseDataType>,\n): IApiSuccessAction<ActionType, Meta, ResponseDataType> {\n    return {\n        type,\n        meta,\n        payload,\n    };\n}\n"],"sourceRoot":""}