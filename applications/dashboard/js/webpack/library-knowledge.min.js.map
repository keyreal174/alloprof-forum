{"version":3,"sources":["webpack://vanillaknowledge/./library/src/scripts/@types/api.ts","webpack://vanillaknowledge/./library/src/scripts/dom.ts","webpack://vanillaknowledge/./library/src/scripts/components/Icons.tsx","webpack://vanillaknowledge/./library/src/scripts/gdn.ts","webpack://vanillaknowledge/./library/src/scripts/apiv2.ts","webpack://vanillaknowledge/./library/src/scripts/state/reducerRegistry.ts","webpack://vanillaknowledge/./library/src/scripts/utility.ts","webpack://vanillaknowledge/./library/src/scripts/embeds.tsx","webpack://vanillaknowledge/./library/src/scripts/application.tsx","webpack://vanillaknowledge/./library/src/scripts/state/utility.ts"],"names":["LoadStatus","__webpack_require__","d","__webpack_exports__","escapeHTML","str","div","document","createElement","appendChild","createTextNode","innerHTML","delegatedEventListeners","delegateEvent","eventName","filterSelector","callback","scopeSelector","scope","functionKey","toString","querySelector","Error","HTMLElement","eventHash","Object","_library_utility__WEBPACK_IMPORTED_MODULE_0__","keys","includes","wrappedCallback","event","match","target","closest","call","addEventListener","removeDelegatedEvent","_a","removeEventListener","dataMap","WeakMap","setData","element","key","value","initialValue","has","get","set","getData","defaultValue","attributeString","hasAttribute","getAttribute","testChar","emojiSupportedCache","isEmojiSupported","canvas","getContext","offset","window","devicePixelRatio","ctx","fillStyle","textBaseline","font","fillText","getImageData","data","emojiOptions","className","size","convertToSafeEmojiCharacters","stringOrNode","twemoji__WEBPACK_IMPORTED_MODULE_1___default","a","parse","loadEventCallbacks","rejectionCache","Map","ensureScript","scriptUrl","Promise","resolve","reject","existingScript","callbacks","push","head","getElementsByTagName","script_1","type","src","onerror","error","timeout_1","setTimeout","onload","clearTimeout","forEach","delete","checkDomTreeHasFocus","rootNode","possibleTargets","activeElement","relatedTarget","explicitOriginalTarget","possibleTargets_1","__values","possibleTargets_1_1","next","done","body","hasFocus","contains","watchFocusInDomTree","triggeringElement","clickedElement","checkDomTreeWasClicked","getDraggedImage","dataTransfer","files","length","preventDefault","Array","from","getPastedImage","clipboardData","items","map","item","getAsFile","filter","Boolean","getElementHeight","previousBottomMargin","height","getBoundingClientRect","getComputedStyle","marginTop","marginBottom","topHeight","parseInt","Math","max","bottomHeight","bottomMargin","_library_application__WEBPACK_IMPORTED_MODULE_2__","currentColorFill","fill","leftChevron","react__WEBPACK_IMPORTED_MODULE_0___default","classnames__WEBPACK_IMPORTED_MODULE_1___default","xmlns","viewBox","aria-hidden","style","close","title","gdn","meta","permissions","translations","api","axios__WEBPACK_IMPORTED_MODULE_2___default","create","baseURL","_library_application__WEBPACK_IMPORTED_MODULE_0__","headers","common","X-Requested-With","transformResponse","__spread","defaults","responseData","status","errors","_library_utility__WEBPACK_IMPORTED_MODULE_1__","paramsSerializer","params","qs__WEBPACK_IMPORTED_MODULE_3___default","stringify","indices","uploadImage","image","FormData","append","name","post","result","sent","haveGot","wasReadyCalled","reducers","registerReducer","reducer","getReducers","__assign","sanitizeUrl","_debug","debug","newValue","undefined","log","_i","arguments","console","apply","logError","logWarning","warn","hashString","split","reduce","prevHash","currVal","charCodeAt","splitStringLoosely","toSplit","splitWith","normalizedName","normalize","replace","normalizedSplitTerm","charactersUsed","RegExp","piece","start","substring","simplifyFraction","numerator","denominator","findGCD","b","gcd","shorthand","matchAtMention","subtext","shouldStartWithSpace","requireQuotesForWhitespace","lines","lastLine","nonExcludedCharacters","excludeWhiteSpace","excluded","regexStr","exec","rawMatch","IMAGE_REGEX","isFileImage","file","test","capitalizeFirstLetter","charAt","toUpperCase","slice","indexArrayByKey","array","object","array_1","array_1_1","SAFE_PROTOCOL_REGEX","url","react_dom__WEBPACK_IMPORTED_MODULE_1__","react_dom__WEBPACK_IMPORTED_MODULE_1___default","n","FOCUS_CLASS","embedRenderers","embedComponents","registerEmbedRenderer","renderer","registerEmbedComponent","component","renderEmbed","elements","inEditor","root","classList","add","content","Component","render","onRenderComplete","validator_lib_isURL__WEBPACK_IMPORTED_MODULE_4__","validator_lib_isURL__WEBPACK_IMPORTED_MODULE_4___default","getMeta","_library_gdn__WEBPACK_IMPORTED_MODULE_2__","parts","haystack","parts_1","parts_1_1","part","hasOwnProperty","t","defaultTranslation","substr","isAllowedUrl","input","protocols","require_tld","require_protocol","require_host","require_valid_protocol","allow_trailing_dot","allow_protocol_relative_urls","formatUrl","path","indexOf","assetUrl","_components","_mountComponents","parent","querySelectorAll","node","toLowerCase","getComponent","_library_utility__WEBPACK_IMPORTED_MODULE_3__","_readyHandlers","onReady","_executeReady","handlerPromises","handler","all","then","readyState","onContent","makeProfileUrl","username","encodeURIComponent","_library_apiv2__WEBPACK_IMPORTED_MODULE_0__","createAction","payload","generateApiActionCreators","requestType","successType","errorType","dummyResponseType","dummyMetaType","request","createApiRequestAction","success","response","createApiSuccessAction","createApiErrorAction","apiThunk","endpoint","actionCreators","dispatch","catch","axiosError"],"mappings":"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","file":"applications/dashboard/js/webpack/library-knowledge.min.js?b66443d1fd640dd62c95","sourcesContent":["/**\n * @copyright 2009-2018 Vanilla Forums Inc.\n * @license GPL-2.0-only\n */\n\nexport const enum LoadStatus {\n    PENDING = \"PENDING\",\n    LOADING = \"LOADING\",\n    SUCCESS = \"SUCCESS\",\n    ERROR = \"ERROR\",\n}\n\ninterface IPendingValue {\n    status: LoadStatus.PENDING;\n    data?: undefined;\n    error?: undefined;\n}\n\ninterface ILoadingValue<T> {\n    status: LoadStatus.LOADING;\n    data?: T;\n    error?: IApiError;\n}\n\ninterface ISuccessValue<T> {\n    status: LoadStatus.SUCCESS;\n    data: T;\n    error?: undefined;\n}\n\ninterface IErrorValue<T> {\n    status: LoadStatus.ERROR;\n    error: IApiError;\n    data?: T;\n}\n\nexport type ILoadable<T> = IPendingValue | ILoadingValue<T> | ISuccessValue<T> | IErrorValue<T>;\n\nexport interface IApiResponse<DataType = any> {\n    data: DataType;\n    status: number;\n    headers: any;\n}\n\nexport interface IFieldError {\n    message: string; // translated message\n    code: string; // translation code\n    field: string;\n    status?: number; // HTTP status\n}\n\nexport interface IApiError {\n    message: string;\n    status: number;\n    errors?: {\n        [key: string]: IFieldError[];\n    };\n}\n","/**\n * Utilities that have a hard dependency on the DOM.\n *\n * @copyright 2009-2018 Vanilla Forums Inc.\n * @license GPL-2.0-only\n */\n\nimport { logError, log, hashString } from \"@library/utility\";\nimport twemoji from \"twemoji\";\nimport tabbable from \"tabbable\";\nimport debounce from \"lodash/debounce\";\nimport TabHandler from \"@library/TabHandler\";\n\n/**\n * Use the browser's built-in functionality to quickly and safely escape a string.\n *\n * @param str - The string to escape.\n *\n * @returns Escaped HTML.\n */\nexport function escapeHTML(str: string): string {\n    const div = document.createElement(\"div\");\n    div.appendChild(document.createTextNode(str));\n    return div.innerHTML;\n}\n\n/**\n * Use the browser's built-in functionality to quickly unescape a string.\n * UNSAFE with unsafe strings; only use on previously-escaped ones!\n *\n * @param escapedString - A previously escaped string.\n *\n * @returns The unescaped string.\n */\nexport function unescapeHTML(escapedString: string): string {\n    const div = document.createElement(\"div\");\n    div.innerHTML = escapedString;\n    const child = div.childNodes[0];\n    return child && child.nodeValue ? child.nodeValue : \"\";\n}\n\n/**\n * Add the hidden class and aria-hidden attribute to an Element.\n *\n * @param element - The DOM Element to modify.\n */\nexport function hideElement(element: Element) {\n    element.classList.add(\"u-isHidden\");\n    element.setAttribute(\"aria-hidden\", \"true\");\n}\n\n/**\n * Remove the hidden class and aria-hidden attribute to an Element.\n *\n * @param element - The DOM Element to modify.\n */\nexport function unhideElement(element: Element) {\n    element.classList.remove(\"u-isHidden\");\n    element.removeAttribute(\"aria-hidden\");\n}\n\n/**\n * Check if an element is visible or not.\n *\n * @param element - The element to check.\n *\n * @returns The visibility.\n */\nexport function elementIsVisible(element: HTMLElement): boolean {\n    return !!(element.offsetWidth || element.offsetHeight || element.getClientRects().length);\n}\n\n/**\n * Get the form data out of a form element.\n *\n * @param {Element} formElement - The element to get the data out of.\n *\n * @returns {Object}\n */\nexport function getFormData(formElement) {\n    if (!(formElement instanceof HTMLFormElement)) {\n        return {};\n    }\n\n    const data = new FormData(formElement) as any;\n    const result = {};\n\n    data.forEach((key, value) => {\n        result[key] = value;\n    });\n\n    return result;\n}\n\nconst delegatedEventListeners = {};\n\n/**\n * Create an event listener using event delegation.\n *\n * @param eventName - The Event to listen for.\n * @param filterSelector - A CSS selector to match against.\n * @param callback - The callback function. This gets passed the fired event.\n * @param scopeSelector - And element to scope the event listener to.\n *\n * @returns The hash of the event. Save this to use removeDelegatedEvent().\n */\nexport function delegateEvent(\n    eventName: string,\n    filterSelector: string,\n    callback: (event: Event, triggeringElement: HTMLElement) => boolean | void,\n    scopeSelector?: string | HTMLElement,\n): string | undefined {\n    let functionKey = eventName + filterSelector + callback.toString();\n\n    let scope;\n\n    if (typeof scopeSelector === \"string\") {\n        scope = document.querySelector(scopeSelector);\n\n        if (!scope) {\n            throw new Error(`Unable to find element in the document for scopeSelector: ${scopeSelector}`);\n        } else {\n            functionKey += scopeSelector;\n        }\n    } else if (scopeSelector instanceof HTMLElement) {\n        scope = scopeSelector;\n    } else {\n        scope = document;\n    }\n\n    const eventHash = hashString(functionKey).toString();\n\n    if (!Object.keys(delegatedEventListeners).includes(eventHash)) {\n        const wrappedCallback = event => {\n            // Get the nearest DOMNode that matches the given selector.\n            const match = filterSelector ? event.target.closest(filterSelector) : event.target;\n\n            if (match) {\n                // Call the callback with the matching element as the context.\n                return callback.call(match, event, match);\n            }\n        };\n\n        const listener = scope.addEventListener(eventName, wrappedCallback);\n        delegatedEventListeners[eventHash] = {\n            scope,\n            eventName,\n            wrappedCallback,\n        };\n        return eventHash;\n    }\n}\n\n/**\n * Remove a delegated event listener.\n *\n * @param eventHash - The event hash passed from delegateEvent().\n */\nexport function removeDelegatedEvent(eventHash: string) {\n    const { scope, eventName, wrappedCallback } = delegatedEventListeners[eventHash];\n    scope.removeEventListener(eventName, wrappedCallback);\n    delete delegatedEventListeners[eventHash];\n}\n\nexport function removeAllDelegatedEvents() {\n    Object.keys(delegatedEventListeners).forEach(key => {\n        removeDelegatedEvent(key);\n    });\n}\n\n/**\n * Toggle any attribute on an element.\n *\n * @param element - The element to toggle on.\n * @param attribute - The attribute to toggle.\n */\nexport function toggleAttribute(element: Element, attribute: string) {\n    const newValue = element.getAttribute(attribute) === \"false\";\n    element.setAttribute(attribute, newValue);\n}\n\nconst dataMap = new WeakMap();\n\n/**\n * Set a piece of data specific to a DOM Element. Similar to `$.data`.\n *\n * @param element - The DOM Element to assosciate the data with.\n * @param key - The key to assosciate the data with.\n * @param value - The value to store.\n */\nexport function setData(element: Element, key: string, value: any) {\n    const initialValue = dataMap.has(element) ? dataMap.get(element) : {};\n    initialValue[key] = value;\n\n    dataMap.set(element, initialValue);\n}\n\n/**\n * Get a piece of data specific to a DOM Element. Similar to `$.data`.\n *\n * @param element - The DOM Element to lookup.\n * @param key - The key to lookup.\n * @param defaultValue - A value to use if the element or key aren't found.\n */\nexport function getData(element: Element, key: string, defaultValue?: any) {\n    if (dataMap.has(element) && dataMap.get(element)[key]) {\n        return dataMap.get(element)[key];\n    }\n\n    const attributeString = `data-${key}`;\n\n    if (element.hasAttribute(attributeString)) {\n        return element.getAttribute(attributeString);\n    }\n\n    return defaultValue;\n}\n\n/**\n * Get an HTML element from a CSS selector or DOM Node.\n *\n * @param {string|Node} selectorOrElement - A CSS selector or an HTML element.\n *\n * @throws {Error} - If no element was found.\n * @returns {HTMLElement} - An HTMLElement no matter what.\n */\nexport function ensureHtmlElement(selectorOrElement) {\n    if (typeof selectorOrElement === \"string\") {\n        selectorOrElement = document.querySelector(selectorOrElement);\n    }\n\n    if (!(selectorOrElement instanceof HTMLElement)) {\n        throw new Error(`HTMLElement could not be found for ${selectorOrElement}.`);\n    }\n\n    return selectorOrElement;\n}\n\n// Test Char for Emoji 5.0\nconst testChar = \"\\uD83E\\uDD96\"; // U+1F996 T-Rex -> update test character with new emoji version support.\n\nlet emojiSupportedCache: boolean | null = null;\n\nexport function isEmojiSupported() {\n    if (emojiSupportedCache !== null) {\n        return emojiSupportedCache;\n    }\n\n    if (process.env.NODE_ENV !== \"test\") {\n        // Test environment\n        const canvas = document.createElement(\"canvas\");\n        if (canvas.getContext && canvas.getContext(\"2d\")) {\n            const pixelRatio = window.devicePixelRatio || 1;\n            const offset = 12 * pixelRatio;\n            const ctx = canvas.getContext(\"2d\");\n            ctx!.fillStyle = \"#f00\";\n            ctx!.textBaseline = \"top\";\n            ctx!.font = \"32px Arial\";\n            ctx!.fillText(testChar, 0, 0);\n            emojiSupportedCache = ctx!.getImageData(offset, offset, 1, 1).data[0] !== 0;\n        } else {\n            emojiSupportedCache = false;\n        }\n    } else {\n        emojiSupportedCache = true;\n    }\n\n    return emojiSupportedCache;\n}\n\nconst emojiOptions = {\n    className: \"fallBackEmoji\",\n    size: \"72x72\",\n};\n\n/**\n * Returns either native emoji or fallback image\n *\n * @param stringOrNode - A DOM Node or string to convert.\n */\nexport function convertToSafeEmojiCharacters(stringOrNode: string | Node) {\n    if (isEmojiSupported()) {\n        return stringOrNode;\n    }\n    return twemoji.parse(stringOrNode, emojiOptions);\n}\n\n// A weakmap so we can store multiple load callbacks per script.\nconst loadEventCallbacks: WeakMap<Node, Array<(event) => void>> = new WeakMap();\nconst rejectionCache: Map<string, Error> = new Map();\n\n/**\n * Dynamically load a javascript file.\n */\nexport function ensureScript(scriptUrl: string) {\n    return new Promise((resolve, reject) => {\n        const existingScript: HTMLScriptElement | null = document.querySelector(`script[src='${scriptUrl}']`);\n        if (rejectionCache.has(scriptUrl)) {\n            reject(rejectionCache.get(scriptUrl));\n        }\n        if (existingScript) {\n            if (loadEventCallbacks.has(existingScript)) {\n                // Add another resolveCallback into the weakmap.\n                const callbacks = loadEventCallbacks.get(existingScript);\n                callbacks && callbacks.push(resolve);\n            } else {\n                // Script is already loaded. Resolve immediately.\n                resolve();\n            }\n        } else {\n            // The script doesn't exist. Lets create it.\n            const head = document.getElementsByTagName(\"head\")[0];\n            const script = document.createElement(\"script\");\n            script.type = \"text/javascript\";\n            script.src = scriptUrl;\n            script.onerror = (event: ErrorEvent) => {\n                const error = new Error(\"Failed to load a required embed script\");\n                rejectionCache.set(scriptUrl, error);\n                reject(error);\n            };\n\n            const timeout = setTimeout(() => {\n                const error = new Error(`Loading of the script ${scriptUrl} has timed out.`);\n                rejectionCache.set(scriptUrl, error);\n                reject(error);\n            }, 10000);\n\n            loadEventCallbacks.set(script, [resolve]);\n\n            script.onload = event => {\n                clearTimeout(timeout);\n                const callbacks = loadEventCallbacks.get(script);\n                callbacks && callbacks.forEach(callback => callback(event));\n                loadEventCallbacks.delete(script);\n            };\n\n            head.appendChild(script);\n        }\n    });\n}\n\ninterface ITabbableOptions {\n    root: Element;\n    excludedElements: Element[];\n    excludedRoots: Element[];\n    reverse: boolean;\n    fromElement: Element;\n    allowLooping: boolean;\n}\n\nfunction checkDomTreeWasClicked(rootNode: Element | null, clickedElement: Element) {\n    return rootNode && clickedElement && (rootNode.contains(clickedElement as Element) || rootNode === clickedElement);\n}\n\n/**\n * Determine if the currently focused element is somewhere inside of (or the same as)\n * a given Element.\n *\n * @param rootNode - The root node to look in.\n */\nfunction checkDomTreeHasFocus(rootNode: Element | null, event: FocusEvent, callback: (hasFocus: boolean) => void) {\n    setTimeout(() => {\n        const possibleTargets = [\n            // NEEDS TO COME FIRST, because safari will populate relatedTarget on focusin, and its not what we're looking for.\n            document.activeElement, // IE11, Safari.\n            event.relatedTarget as Element, // Chrome (The actual standard)\n            (event as any).explicitOriginalTarget, // Firefox\n        ];\n\n        let activeElement = null;\n        for (const target of possibleTargets) {\n            if (target && target !== document.body) {\n                activeElement = target;\n                break;\n            }\n        }\n\n        if (activeElement !== null) {\n            const hasFocus =\n                rootNode && activeElement && (activeElement === rootNode || rootNode.contains(activeElement));\n\n            // We will only invalidate based on something actually getting focus.\n            callback(!!hasFocus);\n        }\n    }, 0);\n}\n\n/**\n * Register a callback for focusin and focusin out events. The main improvement here over registering\n * the listeners yourself is that the events fire for the whole tree as 1 item instead of as\n * individual notes.\n *\n * This is particularly useful when you want to track focus leaving or enterring a component\n * without caring about the individual contents inside.\n *\n * @param rootNode - The root dom node to watch on.\n * @param callback - A callback for when the tree focuses and blurs.\n */\nexport function watchFocusInDomTree(rootNode: Element, callback: (hasFocus: boolean) => void) {\n    rootNode.addEventListener(\n        \"focusout\",\n        (event: FocusEvent) => {\n            checkDomTreeHasFocus(rootNode, event, hasFocus => {\n                !hasFocus && callback(false);\n            });\n        },\n        true,\n    );\n\n    rootNode.addEventListener(\n        \"focusin\",\n        (event: FocusEvent) => {\n            checkDomTreeHasFocus(rootNode, event, hasFocus => {\n                hasFocus && callback(true);\n            });\n        },\n        true,\n    );\n\n    document.addEventListener(\"click\", event => {\n        const triggeringElement = event.target as Element;\n        const wasClicked = checkDomTreeWasClicked(rootNode, triggeringElement);\n        if (!wasClicked) {\n            callback(false);\n        }\n    });\n}\n\n/**\n * Sticky header handling\n */\nfunction handleStickyHeaderState(element, data) {\n    const goingDown = data.lastScrollPos < data.currentScrollPos;\n    const isAtTopOfPage = data.currentScrollPos === 0;\n    const elementHeight = element.offsetHeight;\n    const isPastHeader =\n        element.style.position !== \"fixed\" && element.offsetTop + elementHeight <= data.currentScrollPos;\n    const elementTop = element.style.top !== \"\" ? parseInt(element.style.top, 10) : false;\n\n    element.classList.toggle(\"isScrollingDown\", goingDown);\n    element.classList.toggle(\"isScrollingUp\", !goingDown);\n    element.classList.toggle(\"isAtTop\", isAtTopOfPage);\n\n    if (goingDown) {\n        element.style.position = \"\";\n        if (isPastHeader) {\n            element.style.top = `${data.currentScrollPos - elementHeight}px`;\n        } else {\n            if (!elementTop) {\n                element.style.top = `${data.currentScrollPos}px`;\n            }\n        }\n    } else {\n        // going UP\n        if (data.currentScrollPos <= elementTop) {\n            element.style.top = \"\";\n            element.style.position = \"fixed\";\n        }\n    }\n}\n\n/**\n * Vanilla's default way to handle sticky headers\n */\nexport function stickyHeader() {\n    const header = document.querySelector(\".stickyHeader\");\n    if (header !== null) {\n        let currentScrollPos = Math.max(window.scrollY, 0);\n        let lastScrollPos = -1;\n\n        handleStickyHeaderState(header, {\n            currentScrollPos,\n            lastScrollPos,\n        });\n\n        window.addEventListener(\"scroll\", e => {\n            debounce(\n                () => {\n                    window.requestAnimationFrame(data => {\n                        lastScrollPos = currentScrollPos;\n                        currentScrollPos = Math.max(window.scrollY, 0);\n                        handleStickyHeaderState(header, {\n                            currentScrollPos,\n                            lastScrollPos,\n                        });\n                    });\n                },\n                100,\n                {\n                    leading: true,\n                },\n            )();\n        });\n    } else {\n        log(\"No sticky header found\");\n    }\n}\n\n/**\n * Handler for an file being dragged and dropped.\n *\n * @param event - https://developer.mozilla.org/en-US/docs/Web/API/DragEvent\n */\nexport function getDraggedImage(event: DragEvent): File | undefined {\n    if (event.dataTransfer && event.dataTransfer.files && event.dataTransfer.files.length) {\n        event.preventDefault();\n        const files = Array.from(event.dataTransfer.files);\n\n        // Currently only 1 file is supported.\n        const mainFile = files[0];\n        return mainFile;\n    }\n}\n\n/**\n * Handler for an file being pasted.\n *\n * @param event - https://developer.mozilla.org/en-US/docs/Web/API/DragEvent\n */\nexport function getPastedImage(event: ClipboardEvent): File | undefined | null {\n    if (event.clipboardData && event.clipboardData.items && event.clipboardData.items.length) {\n        const files = Array.from(event.clipboardData.items)\n            .map((item: any) => (item.getAsFile ? item.getAsFile() : null))\n            .filter(Boolean);\n\n        if (files.length > 0) {\n            event.preventDefault();\n            // Currently only 1 file is supported.\n            const mainFile = files[0];\n            return mainFile;\n        }\n    }\n}\n\n/**\n * Calculate the height of element with simulated margin collapse.\n *\n * This is ideal for getting the calculate height of a fixed number of items. (not the entire parent).\n *\n * It considers:\n * - Element height\n * - Padding\n * - Borders\n * - Margins\n * - Margin collapsing.\n *\n * @param element - The element to measure\n * @param previousBottomMargin - The bottom margin of the previous element. You can use the returned bottom margin from this function to get this.\n */\nexport function getElementHeight(\n    element: Element,\n    previousBottomMargin: number = 0,\n): {\n    height: number;\n    bottomMargin: number;\n} {\n    const height = element.getBoundingClientRect().height;\n    const { marginTop, marginBottom } = window.getComputedStyle(element);\n\n    let topHeight = marginTop ? parseInt(marginTop, 10) : 0;\n    // Simulate a margin-collapsed height.\n    topHeight = Math.max(topHeight - previousBottomMargin, 0);\n\n    const bottomHeight = marginBottom ? parseInt(marginBottom, 10) : 0;\n    const finalHeight = height + topHeight + bottomHeight;\n\n    return {\n        height: finalHeight,\n        bottomMargin: bottomHeight,\n    };\n}\n","/*\n * @author Stéphane LaFlèche <stephane.l@vanillaforums.com>\n * @copyright 2009-2018 Vanilla Forums Inc.\n * @license GPL-2.0-only\n */\n\nimport React from \"react\";\nimport classNames from \"classnames\";\nimport { t } from \"@library/application\";\n\nconst currentColorFill = {\n    fill: \"currentColor\",\n};\n\nexport function leftChevron(className?: string) {\n    const title = `<`;\n    return (\n        <svg\n            className={classNames(\"icon\", \"icon-chevronLeft\", className)}\n            xmlns=\"http://www.w3.org/2000/svg\"\n            viewBox=\"0 0 24 24\"\n            aria-hidden=\"true\"\n        >\n            <title>{title}</title>\n            <path\n                d=\"M14.9,7.7l-4.4,4.4,4.4,4.4a.5.5,0,0,1,0,.6l-.6.6a.5.5,0,0,1-.6,0L8.5,12.5a.5.5,0,0,1,0-.6l5.2-5.2a.5.5,0,0,1,.6,0s.676.543.7.7A.325.325,0,0,1,14.9,7.7Z\"\n                style={currentColorFill}\n            />\n        </svg>\n    );\n}\n\nexport function close(className?: string) {\n    const title = t(\"Close\");\n    return (\n        <svg\n            className={classNames(\"icon\", \"icon-close\", className)}\n            xmlns=\"http://www.w3.org/2000/svg\"\n            viewBox=\"0 0 24 24\"\n            aria-hidden=\"true\"\n        >\n            <title>{title}</title>\n            <path\n                fill=\"currentColor\"\n                d=\"M12,10.6293581 L5.49002397,4.11938207 C5.30046135,3.92981944 4.95620859,3.96673045 4.69799105,4.22494799 L4.22494799,4.69799105 C3.97708292,4.94585613 3.92537154,5.29601344 4.11938207,5.49002397 L10.6293581,12 L4.11938207,18.509976 C3.92981944,18.6995387 3.96673045,19.0437914 4.22494799,19.3020089 L4.69799105,19.775052 C4.94585613,20.0229171 5.29601344,20.0746285 5.49002397,19.8806179 L12,13.3706419 L18.509976,19.8806179 C18.6995387,20.0701806 19.0437914,20.0332695 19.3020089,19.775052 L19.775052,19.3020089 C20.0229171,19.0541439 20.0746285,18.7039866 19.8806179,18.509976 L13.3706419,12 L19.8806179,5.49002397 C20.0701806,5.30046135 20.0332695,4.95620859 19.775052,4.69799105 L19.3020089,4.22494799 C19.0541439,3.97708292 18.7039866,3.92537154 18.509976,4.11938207 L12,10.6293581 Z\"\n            />\n        </svg>\n    );\n}\n","/**\n * A module to isolate meta data passed from the server into a single dependency.\n * This should always be used instead of accessing window.gdn directly.\n *\n * @copyright 2009-2018 Vanilla Forums Inc.\n * @license GPL-2.0-only\n */\n\ninterface IGdn {\n    meta: AnyObject;\n    permissions: AnyObject;\n    translations: AnyObject;\n    [key: string]: any;\n}\n\n/** The gdn object may be set in an inline script in the head of the document. */\nconst gdn = window.gdn || {};\n\nif (!(\"meta\" in gdn)) {\n    gdn.meta = {};\n}\n\nif (!(\"permissions\" in gdn)) {\n    gdn.permissions = {};\n}\n\nif (!(\"translations\" in gdn)) {\n    gdn.translations = {};\n}\n\nexport default gdn as IGdn;\n","/**\n * Entrypoint for the APIv2 calls. Prepulates an axios instance with some config settings.\n *\n * @copyright 2009-2018 Vanilla Forums Inc.\n * @license GPL-2.0-only\n */\n\nimport { formatUrl, t } from \"@library/application\";\nimport { isFileImage, indexArrayByKey } from \"@library/utility\";\nimport axios from \"axios\";\nimport qs from \"qs\";\nimport { IEmbedData } from \"@library/embeds\";\nimport { IFieldError, LoadStatus, ILoadable } from \"@library/@types/api\";\n\nfunction fieldErrorTransformer(responseData) {\n    if (responseData.status >= 400 && responseData.errors && responseData.errors.length > 0) {\n        responseData.errors = indexArrayByKey(responseData.errors, \"field\");\n    }\n\n    return responseData;\n}\n\nconst api = axios.create({\n    baseURL: formatUrl(\"/api/v2/\"),\n    headers: {\n        common: {\n            \"X-Requested-With\": \"vanilla\",\n        },\n    },\n    transformResponse: [...axios.defaults.transformResponse, fieldErrorTransformer],\n    paramsSerializer: params => qs.stringify(params, { indices: false }),\n});\n\nexport default api;\n\n/**\n * Upload an image using Vanilla's API v2.\n *\n * @param file - The file to upload.\n *\n * @throws If the file given is not an image. You must check yourself first.\n */\nexport async function uploadImage(image: File): Promise<IEmbedData> {\n    if (!isFileImage(image)) {\n        throw new Error(\n            `Unable to upload an image of type ${image.type}. Supported formats included .gif, .jpg and .png`,\n        );\n    }\n\n    const data = new FormData();\n    data.append(\"file\", image, image.name);\n    data.append(\"type\", \"image\");\n\n    const result = await api.post(\"/media\", data);\n    result.data.type = \"image\";\n    return result.data;\n}\n\n/**\n * Extract a field specific error from an ILoadable if applicable.\n *\n * @param loadable - The loadable to extract from.\n * @param field - The field to extract.\n *\n * @returns an array of IFieldErrors if found or undefined.\n */\nexport function getFieldErrors(loadable: ILoadable<any>, field: string): IFieldError[] | undefined {\n    if (loadable.status === LoadStatus.ERROR || loadable.status === LoadStatus.LOADING) {\n        if (loadable.error && loadable.error.errors && loadable.error.errors[field]) {\n            return loadable.error.errors[field];\n        }\n    }\n}\n\n/**\n * Extract a global error message out of an ILoadable if applicable.\n *\n * @param loadable - The loadable to extract from.\n * @param validFields - Field to check for overriding fields errors from. A global error only shows if there are no valid field errors.\n *\n * @returns A global error message or an undefined.\n */\nexport function getGlobalErrorMessage(loadable: ILoadable<any>, validFields: string[]): string | undefined {\n    if (loadable.status === LoadStatus.ERROR || loadable.status === LoadStatus.LOADING) {\n        for (const field of validFields) {\n            if (getFieldErrors(loadable, field)) {\n                return;\n            }\n        }\n\n        if (loadable.error) {\n            return loadable.error.message || t(\"An error has occurred, please try again.\");\n        }\n    }\n}\n","/**\n * A reducer registry so that we can have dynamically loading reducers.\n *\n * @see http://nicolasgallagher.com/redux-modules-and-code-splitting/\n *\n * @copyright 2009-2018 Vanilla Forums Inc.\n * @license GPL-2.0-only\n */\n\nimport { onReady } from \"@library/application\";\nimport { logError } from \"@library/utility\";\nimport { Reducer, ReducersMapObject } from \"redux\";\n\nlet haveGot = false;\nlet wasReadyCalled = false;\nconst reducers = {};\n\nonReady(() => {\n    wasReadyCalled = true;\n});\n\nexport function registerReducer(name: string, reducer: Reducer) {\n    if (haveGot) {\n        logError(\"Cannot register reducer %s after reducers applied to the store.\", name);\n    } else {\n        reducers[name] = reducer;\n    }\n}\n\nexport function getReducers(): ReducersMapObject<any, any> {\n    haveGot = true;\n\n    if (!wasReadyCalled) {\n        logError(\"getReducers() was called before onReady\");\n    }\n\n    return {\n        ...reducers,\n    };\n}\n\n/**\n * @deprecated\n */\nconst reducerRegistry = {\n    register: registerReducer,\n    getReducers,\n};\n\nexport default reducerRegistry;\n","/**\n * General utility functions.\n * This file should have NO external dependencies other than javascript.\n *\n * @copyright 2009-2018 Vanilla Forums Inc.\n * @license GPL-2.0-only\n */\n\n/**\n * @type {boolean} The current debug setting.\n * @private\n */\nlet _debug = false;\n\n/**\n * Get or set the debug flag.\n *\n * @param newValue - The new value of debug.\n * @returns the current debug setting.\n */\nexport function debug(newValue?: boolean): boolean {\n    if (newValue !== undefined) {\n        _debug = newValue;\n    }\n\n    return _debug;\n}\n\ntype NormalCallback = (...args: any[]) => any;\ntype PromiseCallback = (...args: any[]) => Promise<any>;\n\nexport type PromiseOrNormalCallback = NormalCallback | PromiseCallback;\n\n/**\n * Resolve an array of functions that return promises sequentially.\n *\n * @param promiseFunctions - The functions to execute.\n *\n * @returns An array of all results in sequential order.\n *\n * @example\n * const urls = ['/url1', '/url2', '/url3']\n * const functions = urls.map(url => () => fetch(url))\n * resolvePromisesSequentially(funcs)\n *   .then(console.log)\n *   .catch(console.error)\n */\nexport function resolvePromisesSequentially(promiseFunctions: PromiseOrNormalCallback[]): Promise<any[]> {\n    if (!Array.isArray(promiseFunctions)) {\n        throw new Error(\"First argument needs to be an array of Promises\");\n    }\n\n    return new Promise((resolve, reject) => {\n        let count = 0;\n        let results = [];\n\n        function iterationFunction(previousPromise, currentPromise) {\n            return previousPromise\n                .then(result => {\n                    if (count++ !== 0) {\n                        results = results.concat(result);\n                    }\n\n                    return currentPromise(result, results, count);\n                })\n                .catch(err => reject(err));\n        }\n\n        promiseFunctions = promiseFunctions.concat(() => Promise.resolve());\n\n        promiseFunctions.reduce(iterationFunction, Promise.resolve(false)).then(() => {\n            resolve(results);\n        });\n    });\n}\n\n/**\n * Log something to console.\n *\n * This only prints in debug mode.\n *\n * @param value - The value to log.\n */\nexport function log(...value: any[]) {\n    if (_debug) {\n        // tslint:disable-next-line:no-console\n        console.log(...value);\n    }\n}\n\n/**\n * Log an error to console.\n *\n * @param value - The value to log.\n */\nexport function logError(...value: any[]) {\n    // tslint:disable-next-line:no-console\n    console.error(...value);\n}\n\n/**\n * Log a warning to console.\n *\n * @param value - The value to log.\n */\nexport function logWarning(...value: any[]) {\n    // tslint:disable-next-line:no-console\n    console.warn(...value);\n}\n\n/**\n * A simple, fast method of hashing a string. Similar to Java's hash function.\n * https://stackoverflow.com/a/7616484/1486603\n *\n * @param str - The string to hash.\n *\n * @returns The hash code returned.\n */\nexport function hashString(str: string): number {\n    function hashReduce(prevHash, currVal) {\n        // tslint:disable-next-line:no-bitwise\n        return (prevHash << 5) - prevHash + currVal.charCodeAt(0);\n    }\n    return str.split(\"\").reduce(hashReduce, 0);\n}\n\n/**\n * Split a string in multiple pieces similar to String.prototype.split but ignore most acccent characters.\n *\n * This will still return pieces with accents.\n *\n * @param toSplit The string to split.\n * @param splitWith The string to split with.\n */\nexport function splitStringLoosely(toSplit: string, splitWith: string): string[] {\n    const normalizedName = toSplit.normalize(\"NFD\").replace(/[\\u0300-\\u036f]/g, \"\");\n    const normalizedSplitTerm = splitWith.normalize(\"NFD\").replace(/[\\u0300-\\u036f]/g, \"\");\n    const normalizedPieces = normalizedName.split(new RegExp(`(${normalizedSplitTerm})`, \"i\"));\n\n    let charactersUsed = 0;\n    return normalizedPieces.map(piece => {\n        const start = charactersUsed;\n        charactersUsed += piece.length;\n        return toSplit.substring(start, charactersUsed);\n    });\n}\n\ninterface IClass {\n    new (): any;\n}\n\nexport function isInstanceOfOneOf(needle: any, haystack: IClass[]) {\n    for (const classItem of haystack) {\n        if (needle instanceof classItem) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\nexport function simplifyFraction(numerator: number, denominator: number) {\n    const findGCD = (a, b) => {\n        return b ? findGCD(b, a % b) : a;\n    };\n    const gcd = findGCD(numerator, denominator);\n\n    numerator = numerator / gcd;\n    denominator = denominator / gcd;\n\n    return {\n        numerator,\n        denominator,\n        shorthand: denominator + \":\" + numerator,\n    };\n}\n\ninterface IMentionMatch {\n    match: string;\n    rawMatch: string;\n}\n\n/**\n * Custom matching to allow quotation marks in the matching string as well as spaces.\n * Spaces make things more complicated.\n *\n * @param subtext - The string to be tested.\n * @param shouldStartWithSpace - Should the pattern include a test for a whitespace prefix?\n * @returns Matching string if successful.  Null on failure to match.\n */\nexport function matchAtMention(\n    subtext: string,\n    shouldStartWithSpace: boolean = false,\n    requireQuotesForWhitespace: boolean = true,\n): IMentionMatch | null {\n    // Split the string at the lines to allow for a simpler regex.\n    const lines = subtext.split(\"\\n\");\n    const lastLine = lines[lines.length - 1];\n\n    // If you change this you MUST change the regex in src/scripts/__tests__/legacy.test.js !!!\n    /**\n     * Put together the non-excluded characters.\n     *\n     * @param {boolean} excludeWhiteSpace - Whether or not to exclude whitespace characters.\n     *\n     * @returns {string} A Regex string.\n     */\n    function nonExcludedCharacters(excludeWhiteSpace) {\n        let excluded =\n            \"[^\" +\n            '\"' + // Quote character\n            \"\\\\u0000-\\\\u001f\\\\u007f-\\\\u009f\" + // Control characters\n            \"\\\\u2028\"; // Line terminator\n\n        if (excludeWhiteSpace) {\n            excluded += \"\\\\s\";\n        }\n\n        excluded += \"]\";\n        return excluded;\n    }\n\n    let regexStr =\n        \"@\" + // @ Symbol triggers the match\n        \"(\" +\n        // One or more non-greedy characters that aren't excluded. Whitespace is allowed, but a starting quote is required.\n        '\"(' +\n        nonExcludedCharacters(false) +\n        '+?)\"?' +\n        \"|\" + // Or\n        // One or more non-greedy characters that aren't exluded. Whitespace may be excluded.\n        \"(\" +\n        nonExcludedCharacters(requireQuotesForWhitespace) +\n        '+?)\"?' +\n        \")\" +\n        \"(?:\\\\n|$)\"; // Newline terminates.\n\n    // Determined by at.who library\n    if (shouldStartWithSpace) {\n        regexStr = \"(?:^|\\\\s)\" + regexStr;\n    }\n    const regex = new RegExp(regexStr, \"gi\");\n    const match = regex.exec(lastLine);\n    if (match) {\n        return {\n            rawMatch: match[0],\n            match: match[2] || match[1], // Return either of the matching groups (quoted or unquoted).\n        };\n    }\n\n    // No match\n    return null;\n}\n\n/** This should mirror extensions allowed in Vanilla\\ImageResizer.php */\nconst IMAGE_REGEX = /^image\\/(gif|jpe?g|png)/i;\n\n/**\n * A filter for use with [].filter\n *\n * Matches only image image type files.\n * @private\n *\n * @param file - A File object.\n * @see https://developer.mozilla.org/en-US/docs/Web/API/File\n *\n * @returns Whether or not the file is an acceptable image\n */\nexport function isFileImage(file: File): boolean {\n    if (IMAGE_REGEX.test(file.type)) {\n        return true;\n    }\n\n    log(\"Filtered out non-image file: \", file.name);\n    return false;\n}\n\nexport function capitalizeFirstLetter(str: string): string {\n    return str.charAt(0).toUpperCase() + str.slice(1);\n}\n\n/**\n * Transform an array of objects and an map of objets with a given key.\n *\n * Objects that do not contain the given key are dropped.\n *\n * @param array The array to go through.\n * @param key The key to lookup.\n */\nexport function indexArrayByKey<T extends object>(\n    array: T[],\n    key: string,\n): {\n    [key: string]: T;\n} {\n    const object = {};\n    for (const item of array) {\n        if (key in item) {\n            if (!(item[key] in object)) {\n                object[item[key]] = [];\n            }\n            object[item[key]].push(item);\n        }\n    }\n    return object;\n}\n\nconst SAFE_PROTOCOL_REGEX = /^(http:\\/\\/|https:\\/\\/|tel:|mailto:\\/\\/)/;\n\n/**\n * Sanitize a URL to ensure that it matches a whitelist of approved url schemes. If the url does not match one of these schemes, prepend `unsafe:` before it.\n *\n * Allowed protocols\n * - \"http://\",\n * - \"https://\",\n * - \"tel:\",\n * - \"mailto://\",\n *\n * @param url The url to sanitize.\n */\nexport function sanitizeUrl(url: string) {\n    if (url.match(SAFE_PROTOCOL_REGEX)) {\n        return url;\n    } else {\n        return \"unsafe:\" + url;\n    }\n}\n","/**\n * Embed utility functions and types.\n * This file should have NO external dependencies other than javascript.\n *\n * @copyright 2009-2018 Vanilla Forums Inc.\n * @license GPL-2.0-only\n */\n\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport { IDiscussionEmbed, ICommentEmbed, IScrapeData } from \"@dashboard/@types/api\";\n\nexport const FOCUS_CLASS = \"embed-focusableElement\";\n\nexport type IQuoteEmbedData = IDiscussionEmbed | ICommentEmbed;\nexport type IEmbedData = IScrapeData;\n\nexport interface IEmbedElements {\n    root: HTMLElement;\n    content: HTMLElement;\n}\n\nexport type EmbedRenderer = (elements: IEmbedElements, data: IEmbedData, inEditor: boolean) => Promise<void>;\n\nexport interface IEmbedProps<T = IScrapeData> {\n    data: T;\n    inEditor: boolean;\n    onRenderComplete: () => void;\n}\n\nconst embedRenderers: {\n    [type: string]: EmbedRenderer;\n} = {};\nconst embedComponents: {\n    [type: string]: React.ComponentClass<IEmbedProps>;\n} = {};\n\n/**\n * Get all of the registered embed types.\n */\nexport function getEditorEmbedTypes() {\n    return Object.keys(embedRenderers);\n}\n\n/**\n * Register an embed rendering function.\n */\nexport function registerEmbedRenderer(type: string, renderer: EmbedRenderer) {\n    embedRenderers[type] = renderer;\n}\n\n/**\n * Register an embed rendering function.\n */\nexport function registerEmbedComponent(type: string, component: React.ComponentClass<IEmbedProps>) {\n    embedComponents[type] = component;\n}\n\n/**\n * Render an embed into a DOM node based on it's type.\n */\nexport function renderEmbed(elements: IEmbedElements, data: IEmbedData, inEditor = true): Promise<void> {\n    return new Promise((resolve, reject) => {\n        if (!data.type) {\n            throw new Error(\"The embed type was not provided.\");\n        }\n\n        if (data.type === \"link\") {\n            elements.root.classList.add(\"embedText\");\n            elements.content.classList.add(\"embedText-content\");\n            elements.content.classList.add(\"embedLink-content\");\n        }\n\n        if (data.type === \"quote\") {\n            elements.root.classList.add(\"embedText\");\n            elements.content.classList.add(\"embedText-content\");\n            elements.content.classList.add(\"embedQuote-content\");\n        }\n\n        const renderer = data.type && embedRenderers[data.type];\n        const Component = data.type && embedComponents[data.type];\n\n        if (renderer) {\n            return renderer(elements, data, inEditor);\n        } else if (Component) {\n            ReactDOM.render(\n                <Component data={data as IScrapeData} inEditor={inEditor} onRenderComplete={resolve} />,\n                elements.content,\n            );\n        } else {\n            throw new Error(\"Could not find a renderer for the embed type - \" + data.type);\n        }\n    });\n}\n","/**\n * Application functions for interop between Components in different packages.\n *\n * @copyright 2009-2018 Vanilla Forums Inc.\n * @license GPL-2.0-only\n */\n\nimport React, { ComponentClass } from \"react\";\nimport ReactDOM from \"react-dom\";\nimport { RouteProps } from \"react-router-dom\";\nimport gdn from \"@library/gdn\";\nimport { PromiseOrNormalCallback, logError } from \"@library/utility\";\nimport isUrl from \"validator/lib/isURL\";\n\n/**\n * Get a piece of metadata passed from the server.\n *\n * @param key - The key to lookup.\n * @param defaultValue - A fallback value in case the key cannot be found.\n *\n * @returns Returns a meta value or the default value.\n */\nexport function getMeta(key: string, defaultValue?: any) {\n    if (!gdn.meta) {\n        return defaultValue;\n    }\n\n    const parts = key.split(\".\");\n    let haystack = gdn.meta;\n\n    for (const part of parts) {\n        if (!haystack.hasOwnProperty(part)) {\n            return defaultValue;\n        }\n        haystack = haystack[part];\n    }\n    return haystack;\n}\n\n/**\n * Set a piece of metadata. This will override what was passed from the server.\n *\n * @param key - The key to store under.\n * @param value - The value to set.\n */\nexport function setMeta(key: string, value: any) {\n    const parts = key.split(\".\");\n    const last = parts.pop();\n\n    if (!last) {\n        throw new Error(`Unable to set meta value ${key}. ${last} is not a valid object key.`);\n    }\n\n    let haystack = gdn.meta;\n\n    for (const part of parts) {\n        if (haystack[part] === null || typeof haystack[part] !== \"object\") {\n            haystack[part] = {};\n        }\n        haystack = haystack[part];\n    }\n    haystack[last] = value;\n}\n\n/**\n * Translate a string into the current locale.\n *\n * @param str - The string to translate.\n * @param defaultTranslation - The default translation to use.\n *\n * @returns Returns the translation or the default.\n */\nexport function translate(str: string, defaultTranslation?: string): string {\n    // Codes that begin with @ are considered literals.\n    if (str.substr(0, 1) === \"@\") {\n        return str.substr(1);\n    }\n\n    if (gdn.translations[str] !== undefined) {\n        return gdn.translations[str];\n    }\n\n    return defaultTranslation !== undefined ? defaultTranslation : str;\n}\n\n/**\n * The t function is an alias for translate.\n */\nexport const t = translate;\n\n/**\n * Determine if a string is an allowed URL.\n *\n * In the future this may be extended to check if we want to whitelist/blacklist various URLs.\n *\n * @param input - The string to check.\n */\nexport function isAllowedUrl(input: string): boolean {\n    // Options https://github.com/chriso/validator.js#validators\n    const options = {\n        protocols: [\"http\", \"https\"],\n        require_tld: true,\n        require_protocol: true,\n        require_host: true,\n        require_valid_protocol: true,\n        allow_trailing_dot: false,\n        allow_protocol_relative_urls: false,\n    };\n    return isUrl(input, options);\n}\n\n/**\n * Format a URL in the format passed from the controller.\n *\n * @param path - The path to format.\n *\n * @returns Returns a URL that can be used in the APP.\n */\nexport function formatUrl(path: string): string {\n    if (path.indexOf(\"//\") >= 0) {\n        return path;\n    } // this is an absolute path.\n\n    // The context paths that come down are expect to have no / at the end of them.\n    // Normally a domain like so: https://someforum.com\n    // When we don't have that we want to fallback to \"\" so that our path with a / can get passed.\n    const urlFormat = getMeta(\"context.basePath\", \"\");\n    return urlFormat + path;\n}\n\n/**\n * Create the URL of an asset of the site.\n *\n * @param path - The path to format.\n *\n * @returns Returns a URL that can be used for a static asset.\n */\nexport function assetUrl(path: string): string {\n    if (path.indexOf(\"//\") >= 0) {\n        return path;\n    } // this is an absolute path.\n\n    // The context paths that come down are expect to have no / at the end of them.\n    // Normally a domain like so: https://someforum.com\n    // When we don't have that we want to fallback to \"\" so that our path with a / can get passed.\n    const urlFormat = getMeta(\"context.assetPath\", \"\");\n    return urlFormat + path;\n}\n\n/**\n * @type {Object} The currently registered Components.\n * @private\n */\nconst _components = {};\n\n/**\n * Register a component in the Components registry.\n *\n * @param name The name of the component.\n * @param component The component to register.\n */\nexport function addComponent(name: string, component: ComponentClass) {\n    _components[name.toLowerCase()] = component;\n}\n\n/**\n * Test to see if a component has been registered.\n *\n * @param name The name of the component to test.\n * @returns Returns **true** if the component has been registered or **false** otherwise.\n */\nexport function componentExists(name: string): boolean {\n    return _components[name.toLowerCase()] !== undefined;\n}\n\n/**\n * Get a component from the component registry.\n *\n * @param name The name of the component.\n * @returns Returns the component or **undefined** if there is no registered component.\n */\nexport function getComponent(name: string): ComponentClass | undefined {\n    return _components[name.toLowerCase()];\n}\n\n/**\n * Mount all declared Components on the dom.\n *\n * The page signifies that an element contains a component with the `data-react=\"<Component>\"` attribute.\n *\n * @param parent - The parent element to search. This element is not included in the search.\n */\nexport function _mountComponents(parent: Element) {\n    const nodes = parent.querySelectorAll(\"[data-react]\").forEach(node => {\n        const name = node.getAttribute(\"data-react\") || \"\";\n        const Component = getComponent(name);\n\n        if (Component) {\n            ReactDOM.render(<Component />, node);\n        } else {\n            logError(\"Could not find component %s.\", name);\n        }\n    });\n}\n\n/**\n * @type {Array} The currently registered routes.\n * @private\n */\nconst _routes: any[] = [];\n\n/**\n * Register one or more routes to the app component.\n *\n * @param routes An array of routes to add.\n */\nexport function addRoutes(routes: Array<React.ReactElement<RouteProps>>) {\n    if (!Array.isArray(routes)) {\n        _routes.push(routes);\n    } else {\n        _routes.push(...routes);\n    }\n}\n\n/**\n * Get all of the currently registered routes.\n *\n * @returns Returns an array of routes.\n */\nexport function getRoutes(): Array<React.ReactElement<RouteProps>> {\n    return _routes;\n}\n\n/**\n * @type {Array}\n * @private\n */\nconst _readyHandlers: PromiseOrNormalCallback[] = [];\n\n/**\n * Register a callback that executes when the document and the core libraries are ready to use.\n *\n * @param callback - The function to call. This can return a Promise but doesn't have to.\n */\nexport function onReady(callback: PromiseOrNormalCallback) {\n    _readyHandlers.push(callback);\n}\n\n/**\n * Execute all of the registered events in order.\n *\n * @returns A Promise when the events have all fired.\n */\nexport function _executeReady(): Promise<any[]> {\n    return new Promise(resolve => {\n        const handlerPromises = _readyHandlers.map(handler => handler());\n        const exec = () => {\n            return Promise.all(handlerPromises).then(resolve);\n        };\n\n        if (document.readyState !== \"loading\") {\n            return exec();\n        } else {\n            document.addEventListener(\"DOMContentLoaded\", exec);\n        }\n    });\n}\n\n/**\n * Execute a callback when a piece of DOM content is ready to be operated on.\n *\n * This is similar to onReady() but also includes content that is added dynamically (ex. AJAX).\n * Note that this function is meant to bridge the non-react parts of the application with react.\n *\n * @param {function} callback - The callback to execute.\n */\nexport function onContent(callback) {\n    document.addEventListener(\"X-DOMContentReady\", callback);\n}\n\n/**\n * Make a URL to a user's profile.\n */\nexport function makeProfileUrl(username: string) {\n    const userPath = `/profile/${encodeURIComponent(username)}`;\n    return formatUrl(userPath);\n}\n","/**\n * State utility functions.\n *\n * @copyright 2009-2018 Vanilla Forums Inc.\n * @license GPL-2.0-only\n */\n\nimport { IApiResponse, IApiError } from \"@library/@types/api\";\nimport apiv2 from \"@library/apiv2\";\nimport { AxiosResponse, AxiosError } from \"axios\";\n\n// Utility to pull a group of action types out of an actions object\nexport type ActionsUnion<A extends IActionCreatorsMapObject> = ReturnType<A[keyof A]>;\n\n// Utility to create a generic action action.\n\n/**\n * Utility to create an action with our a without a payload of a given type.\n * The action generated can have its type narrowed in a reducer switch statement if the type T matches.\n *\n * @see ActionsUnion\n *\n * @param type The action type.\n * @param payload The payload data.\n */\nexport function createAction<ActionType extends string>(type: ActionType): IAction<ActionType>;\nexport function createAction<ActionType extends string, Payload>(\n    type: ActionType,\n    payload: Payload,\n): IActionWithPayload<ActionType, Payload>;\nexport function createAction<ActionType extends string, Payload>(type: ActionType, payload?: Payload) {\n    return payload === undefined ? { type } : { type, payload };\n}\n\n/**\n * Create request, response, and error action creators.\n *\n * The dummy types are needed because typescript currently requires all generic types to be specified or all to be inferred. They cannot currently be mixed.\n *\n * @see https://github.com/Microsoft/TypeScript/issues/10571#issuecomment-345402872\n *\n * @param requestType The string for the request type. This should be a unique constant.\n * @param successType The string for the success type. This should be a unique constant.\n * @param errorType The string for the error type. This should be a unique constant.\n * @param dummyResponseType A placeholder to infer the type of the response. This isn't used for anything other than inferring a type.\n * @param dummyMetaType A placeholder to infer the type of the meta. This isn't used for anything other than inferringa  type.\n *\n * @example\n *\n * ```\n * const GET_THING_REQUEST = \"GET_THING_REQUEST\";\n * const GET_THING_SUCCESS = \"GET_THING_SUCCESS\";\n * const GET_THING_ERROR = \"GET_THING_ERROR\";\n * interface IThing { thing: string }\n * interface IThingOptions { page?: number }\n *\n * generateApiActionCreators(GET_THING_REQUEST, GET_THING_SUCCESS, GET_THING_ERROR, {} as IThing, {} as IThingOptions);\n * ```\n */\nexport function generateApiActionCreators<\n    RequestActionType extends string,\n    SuccessActionType extends string,\n    ErrorActionType extends string,\n    ResponseDataType,\n    Meta = any\n>(\n    requestType: RequestActionType,\n    successType: SuccessActionType,\n    errorType: ErrorActionType,\n    dummyResponseType?: ResponseDataType,\n    dummyMetaType?: Meta,\n): {\n    request: (meta?: Meta) => IApiAction<RequestActionType, Meta>;\n    success: (\n        payload: IApiResponse<ResponseDataType>,\n        meta?: Meta,\n    ) => IApiSuccessAction<SuccessActionType, Meta, ResponseDataType>;\n    error: (error: IApiError, meta?: Meta) => IApiErrorAction<ErrorActionType, Meta>;\n} {\n    return {\n        request: (meta: Meta) => createApiRequestAction(requestType, meta),\n        success: (response: IApiResponse<ResponseDataType>, meta: Meta) =>\n            createApiSuccessAction(successType, meta, response),\n        error: (error: IApiError, meta: Meta) => createApiErrorAction(errorType, meta, error),\n    };\n}\n\ntype GeneratedActionCreators = ReturnType<typeof generateApiActionCreators>;\n\n// Thunk types\ntype RequestType = \"get\" | \"post\" | \"put\" | \"delete\" | \"patch\";\nexport function apiThunk(\n    requestType: RequestType,\n    endpoint: string,\n    actionCreators: GeneratedActionCreators,\n    params: any,\n) {\n    return dispatch => {\n        dispatch(actionCreators.request(params));\n        apiv2[requestType as any](endpoint, params)\n            .then((response: AxiosResponse) => {\n                dispatch(actionCreators.success(response, params));\n            })\n            .catch((axiosError: AxiosError) => {\n                const error = axiosError.response ? axiosError.response.data : (axiosError as any);\n                dispatch(actionCreators.error(error));\n            });\n    };\n}\n\n// Action interfaces\nexport interface IAction<T extends string> {\n    type: T;\n}\n\nexport interface IActionWithPayload<T extends string, P> extends IAction<T> {\n    payload: P;\n}\n\nexport interface IActionCreator<T extends string> {\n    (): IAction<T>;\n}\n\ntype FunctionType = (...args: any[]) => any;\ninterface IActionCreatorsMapObject {\n    [actionCreator: string]: FunctionType;\n}\n\n// API Action interfaces\ninterface IApiAction<ActionType, Meta> {\n    type: ActionType;\n    meta: Meta;\n}\n\ninterface IApiErrorAction<ActionType, Meta> extends IApiAction<ActionType, Meta> {\n    payload: IApiError;\n}\n\ninterface IApiSuccessAction<ActionType, Meta, ResponseDataType> extends IApiAction<ActionType, Meta> {\n    payload: IApiResponse<ResponseDataType>;\n}\n\n/**\n * Create an API request action. For use in createApiActions().\n *\n * @param type The action's type.\n * @param meta The type of the meta for the action.\n */\nfunction createApiRequestAction<ActionType extends string, Meta>(\n    type: ActionType,\n    meta: Meta,\n): IApiAction<ActionType, Meta> {\n    return {\n        type,\n        meta,\n    };\n}\n\n/**\n * Create an API error action. For use in createApiActions().\n *\n * @param type The action's type.\n * @param meta The type of the meta for the action.\n * @param error An API error.\n */\nfunction createApiErrorAction<ActionType extends string, Meta>(\n    type: ActionType,\n    meta: Meta,\n    error: IApiError,\n): IApiErrorAction<ActionType, Meta> {\n    return {\n        type,\n        meta,\n        payload: error,\n    };\n}\n\n/**\n * Create an API success action. For use in createApiActions().\n *\n * @param type The action's type.\n * @param meta The type of the meta for the action.\n * @param payload The shape of the IApiResponse data.\n */\nfunction createApiSuccessAction<ActionType extends string, Meta, ResponseDataType>(\n    type: ActionType,\n    meta: Meta,\n    payload: IApiResponse<ResponseDataType>,\n): IApiSuccessAction<ActionType, Meta, ResponseDataType> {\n    return {\n        type,\n        meta,\n        payload,\n    };\n}\n"],"sourceRoot":""}