{"version":3,"sources":["webpack:///./applications/dashboard/src/scripts/application.tsx","webpack:///./applications/dashboard/src/scripts/legacy/atwho.ts","webpack:///./build/entries/public-path.ts","webpack:///./applications/dashboard/src/scripts/utility.ts","webpack:///./applications/dashboard/src/scripts/@types/api/general.ts","webpack:///./applications/dashboard/src/scripts/@types/api/authenticate.ts","webpack:///./applications/dashboard/src/scripts/gdn.ts","webpack:///./applications/dashboard/src/scripts/apiv2.ts","webpack:///./applications/dashboard/src/scripts/legacy/index.ts","webpack:///./applications/dashboard/src/scripts/entries/bootstrap.ts"],"names":["getMeta","key","defaultValue","_dashboard_gdn__WEBPACK_IMPORTED_MODULE_2__","meta","parts","split","haystack","parts_1","__values","parts_1_1","next","done","part","value","hasOwnProperty","setMeta","last","pop","Error","parts_2","parts_2_1","translate","str","defaultTranslation","substr","undefined","translations","t","isAllowedUrl","input","validator_lib_isURL__WEBPACK_IMPORTED_MODULE_4___default","protocols","require_tld","require_protocol","require_host","require_valid_protocol","allow_trailing_dot","allow_protocol_relative_urls","formatUrl","path","indexOf","urlFormat","replace","_components","addComponent","name","component","toLowerCase","componentExists","getComponent","_mountComponents","parent","querySelectorAll","forEach","node","getAttribute","Component","react_dom__WEBPACK_IMPORTED_MODULE_1___default","a","render","react__WEBPACK_IMPORTED_MODULE_0___default","createElement","Object","_dashboard_utility__WEBPACK_IMPORTED_MODULE_3__","_routes","addRoutes","routes","Array","isArray","push","apply","__spread","getRoutes","_readyHandlers","onReady","callback","_executeReady","Promise","resolve","handlerPromises","map","handler","exec","all","then","document","readyState","addEventListener","onContent","makeProfileUrl","username","encodeURIComponent","rawMatch","atCache","atEmpty","minCharacters","_dashboard_application__WEBPACK_IMPORTED_MODULE_0__","maxSuggestions","serverLimit","emojiData","emojis","emoji","emojiFormat","format","emojiAssetPath","assetPath","emojiList","entries","_a","_b","__read","index","emojiImageUrl","filename","basename","ext","emojiContentTemplate","emojiTemplate","matchAtMention","flag","subtext","shouldStartWithSpace","match","_dashboard_utility__WEBPACK_IMPORTED_MODULE_1__","matchFakeEmoji","RegExp","initializeAtComplete","editorElement","iframe","iframeWindow","contentWindow","$","atwho","at","tpl","limit","callbacks","remote_filter","query","length","shouldContinueFiltering","filterString","i","l","slice","isQueryEmpty","getJSON","q","data","result","before_insert","$li","requiresQuotation","test","hasQuotation","insert","this","highlighter","li","regexp","$1","$2","$3","$4","matcher","cWindow","insert_tpl","tplEval","on","event","offset","context","suggestionElement","view","$el","$inputor","lineHeight","parseInt","css","iframeOffset","leftCoordinate","left","topCoordinate","top","selectHeight","text","fontMirror","font","fontWidth","width","each","element","outerHeight","height","windowHeight","window","scrollPosition","scrollTop","newOffset","potentialPublicPath","gdn","WebRoot","finalPublicPath","__webpack_require__","p","_debug","debug","newValue","resolvePromisesSequentially","promiseFunctions","reject","count","results","concat","reduce","previousPromise","currentPromise","catch","err","log","_i","arguments","console","logError","error","logWarning","warn","hashString","prevHash","currVal","charCodeAt","splitStringLoosely","toSplit","splitWith","normalizedName","normalize","normalizedSplitTerm","charactersUsed","piece","start","substring","isInstanceOfOneOf","needle","haystack_1","haystack_1_1","simplifyFraction","numerator","denominator","findGCD","b","gcd","shorthand","requireQuotesForWhitespace","lines","lastLine","nonExcludedCharacters","excludeWhiteSpace","excluded","regexStr","IMAGE_REGEX","isFileImage","file","type","capitalizeFirstLetter","charAt","toUpperCase","indexArrayByKey","array","object","array_1","array_1_1","item","SAFE_PROTOCOL_REGEX","sanitizeUrl","url","LoadStatus","AuthenticationStep","permissions","__webpack_exports__","fieldErrorTransformer","responseData","status","errors","api","axios__WEBPACK_IMPORTED_MODULE_2___default","create","baseURL","headers","common","X-Requested-With","transformResponse","defaults","paramsSerializer","params","qs__WEBPACK_IMPORTED_MODULE_3___default","stringify","indices","uploadImage","image","FormData","append","post","sent","getFieldErrors","loadable","field","_dashboard_types_api__WEBPACK_IMPORTED_MODULE_4__","ERROR","LOADING","getGlobalErrorMessage","validFields","validFields_1","validFields_1_1","message","fn","application","atCompleteInit","utility","apiv2","e","target","contentEvent","CustomEvent","bubbles","cancelable","dispatchEvent"],"mappings":"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","file":"/js/webpack/bootstrap-admin.min.js","sourcesContent":["/**\n * Application functions for interop between Components in different packages.\n *\n * @copyright 2009-2018 Vanilla Forums Inc.\n * @license https://opensource.org/licenses/GPL-2.0 GPL-2.0\n */\n\nimport React, { ComponentClass } from \"react\";\nimport ReactDOM from \"react-dom\";\nimport { RouteProps } from \"react-router-dom\";\nimport gdn from \"@dashboard/gdn\";\nimport { PromiseOrNormalCallback, logError } from \"@dashboard/utility\";\nimport isUrl from \"validator/lib/isURL\";\n\n/**\n * Get a piece of metadata passed from the server.\n *\n * @param key - The key to lookup.\n * @param defaultValue - A fallback value in case the key cannot be found.\n *\n * @returns Returns a meta value or the default value.\n */\nexport function getMeta(key: string, defaultValue?: any) {\n    if (!gdn.meta) {\n        return defaultValue;\n    }\n\n    const parts = key.split(\".\");\n    let haystack = gdn.meta;\n\n    for (const part of parts) {\n        if (!haystack.hasOwnProperty(part)) {\n            return defaultValue;\n        }\n        haystack = haystack[part];\n    }\n    return haystack;\n}\n\n/**\n * Set a piece of metadata. This will override what was passed from the server.\n *\n * @param key - The key to store under.\n * @param value - The value to set.\n */\nexport function setMeta(key: string, value: any) {\n    const parts = key.split(\".\");\n    const last = parts.pop();\n\n    if (!last) {\n        throw new Error(`Unable to set meta value ${key}. ${last} is not a valid object key.`);\n    }\n\n    let haystack = gdn.meta;\n\n    for (const part of parts) {\n        if (haystack[part] === null || typeof haystack[part] !== \"object\") {\n            haystack[part] = {};\n        }\n        haystack = haystack[part];\n    }\n    haystack[last] = value;\n}\n\n/**\n * Translate a string into the current locale.\n *\n * @param str - The string to translate.\n * @param defaultTranslation - The default translation to use.\n *\n * @returns Returns the translation or the default.\n */\nexport function translate(str: string, defaultTranslation?: string): string {\n    // Codes that begin with @ are considered literals.\n    if (str.substr(0, 1) === \"@\") {\n        return str.substr(1);\n    }\n\n    if (gdn.translations[str] !== undefined) {\n        return gdn.translations[str];\n    }\n\n    return defaultTranslation !== undefined ? defaultTranslation : str;\n}\n\n/**\n * The t function is an alias for translate.\n */\nexport const t = translate;\n\n/**\n * Determine if a string is an allowed URL.\n *\n * In the future this may be extended to check if we want to whitelist/blacklist various URLs.\n *\n * @param input - The string to check.\n */\nexport function isAllowedUrl(input: string): boolean {\n    // Options https://github.com/chriso/validator.js#validators\n    const options = {\n        protocols: [\"http\", \"https\"],\n        require_tld: true,\n        require_protocol: true,\n        require_host: true,\n        require_valid_protocol: true,\n        allow_trailing_dot: false,\n        allow_protocol_relative_urls: false,\n    };\n    return isUrl(input, options);\n}\n\n/**\n * Format a URL in the format passed from the controller.\n *\n * @param path - The path to format.\n *\n * @returns Returns a URL that can be used in the APP.\n */\nexport function formatUrl(path: string): string {\n    if (path.indexOf(\"//\") >= 0) {\n        return path;\n    } // this is an absolute path.\n\n    const urlFormat = getMeta(\"UrlFormat\", \"/{Path}\");\n\n    if (path.substr(0, 1) === \"/\") {\n        path = path.substr(1);\n    }\n\n    if (urlFormat.indexOf(\"?\") >= 0) {\n        path = path.replace(\"?\", \"&\");\n    }\n\n    return urlFormat.replace(\"{Path}\", path);\n}\n\n/**\n * @type {Object} The currently registered Components.\n * @private\n */\nconst _components = {};\n\n/**\n * Register a component in the Components registry.\n *\n * @param name The name of the component.\n * @param component The component to register.\n */\nexport function addComponent(name: string, component: ComponentClass) {\n    _components[name.toLowerCase()] = component;\n}\n\n/**\n * Test to see if a component has been registered.\n *\n * @param name The name of the component to test.\n * @returns Returns **true** if the component has been registered or **false** otherwise.\n */\nexport function componentExists(name: string): boolean {\n    return _components[name.toLowerCase()] !== undefined;\n}\n\n/**\n * Get a component from the component registry.\n *\n * @param name The name of the component.\n * @returns Returns the component or **undefined** if there is no registered component.\n */\nexport function getComponent(name: string): ComponentClass | undefined {\n    return _components[name.toLowerCase()];\n}\n\n/**\n * Mount all declared Components on the dom.\n *\n * The page signifies that an element contains a component with the `data-react=\"<Component>\"` attribute.\n *\n * @param parent - The parent element to search. This element is not included in the search.\n */\nexport function _mountComponents(parent: Element) {\n    const nodes = parent.querySelectorAll(\"[data-react]\").forEach(node => {\n        const name = node.getAttribute(\"data-react\") || \"\";\n        const Component = getComponent(name);\n\n        if (Component) {\n            ReactDOM.render(<Component />, node);\n        } else {\n            logError(\"Could not find component %s.\", name);\n        }\n    });\n}\n\n/**\n * @type {Array} The currently registered routes.\n * @private\n */\nconst _routes: any[] = [];\n\n/**\n * Register one or more routes to the app component.\n *\n * @param routes An array of routes to add.\n */\nexport function addRoutes(routes: Array<React.ReactElement<RouteProps>>) {\n    if (!Array.isArray(routes)) {\n        _routes.push(routes);\n    } else {\n        _routes.push(...routes);\n    }\n}\n\n/**\n * Get all of the currently registered routes.\n *\n * @returns Returns an array of routes.\n */\nexport function getRoutes(): Array<React.ReactElement<RouteProps>> {\n    return _routes;\n}\n\n/**\n * @type {Array}\n * @private\n */\nconst _readyHandlers: PromiseOrNormalCallback[] = [];\n\n/**\n * Register a callback that executes when the document and the core libraries are ready to use.\n *\n * @param callback - The function to call. This can return a Promise but doesn't have to.\n */\nexport function onReady(callback: PromiseOrNormalCallback) {\n    _readyHandlers.push(callback);\n}\n\n/**\n * Execute all of the registered events in order.\n *\n * @returns A Promise when the events have all fired.\n */\nexport function _executeReady(): Promise<any[]> {\n    return new Promise(resolve => {\n        const handlerPromises = _readyHandlers.map(handler => handler());\n        const exec = () => {\n            return Promise.all(handlerPromises).then(resolve);\n        };\n\n        if (document.readyState !== \"loading\") {\n            return exec();\n        } else {\n            document.addEventListener(\"DOMContentLoaded\", exec);\n        }\n    });\n}\n\n/**\n * Execute a callback when a piece of DOM content is ready to be operated on.\n *\n * This is similar to onReady() but also includes content that is added dynamically (ex. AJAX).\n * Note that this function is meant to bridge the non-react parts of the application with react.\n *\n * @param {function} callback - The callback to execute.\n */\nexport function onContent(callback) {\n    document.addEventListener(\"X-DOMContentReady\", callback);\n}\n\n/**\n * Make a URL to a user's profile.\n */\nexport function makeProfileUrl(username: string) {\n    const userPath = `/profile/${encodeURIComponent(username)}`;\n    return formatUrl(userPath);\n}\n","/**\n * At-who setup for legacy @mentions.\n *\n * @copyright 2009-2018 Vanilla Forums Inc.\n * @license https://opensource.org/licenses/GPL-2.0 GPL-2.0\n */\n\nimport { formatUrl, getMeta } from \"@dashboard/application\";\nimport { log, matchAtMention as _matchAtMention } from \"@dashboard/utility\";\n\n// Store cache results in an outer scoped variable., so all instances share the same data\n// and can build the cache together.\nconst atCache = {};\nconst atEmpty = {};\n\n// The current raw match. This is needed to properly match quoted strings.\nlet rawMatch: string | undefined;\n\n// Set minimum characters to type for @mentions to fire\nconst minCharacters = getMeta(\"mentionMinChars\", 2);\n\n// Max suggestions to show in dropdown.\nconst maxSuggestions = getMeta(\"mentionSuggestionCount\", 5);\n\n// Server response limit. This should match the limit set in\n// *UserController->TagSearch* and UserModel->TagSearch\nconst serverLimit = 30;\n\n// Emoji, set in definition list in foot, by Emoji class. Make sure\n// that class is getting instantiated, otherwise emoji will be empty.\n\ninterface IEmojiData {\n    assetPath?: string;\n    emoji?: {\n        [key: string]: string;\n    };\n    format?: string;\n}\n\nconst emojiData: IEmojiData = getMeta(\"emoji\", {});\nconst emojis = emojiData.emoji || {};\nconst emojiFormat = emojiData.format || \"\";\nconst emojiAssetPath = emojiData.assetPath || \"\";\n\nconst emojiList = Object.entries(emojis).map(([index, emojiImageUrl]) => {\n    const parts = emojiImageUrl.split(\".\");\n\n    return { name: index, filename: emojiImageUrl, basename: parts[0], ext: \".\" + parts[1] };\n});\n\nconst emojiContentTemplate = emojiFormat\n    .replace(/{(.+?)}/g, \"$${$1}\")\n    .replace(\"%1$s\", \"${src}\")\n    .replace(\"%2$s\", \"${name}\")\n    .replace(\"${src}\", emojiAssetPath + \"/${filename}\")\n    .replace(\"${dir}\", emojiAssetPath);\nconst emojiTemplate =\n    '<li data-value=\":${name}:\" class=\"at-suggest-emoji\"><span class=\"emoji-wrap\">' +\n    emojiContentTemplate +\n    '</span> <span class=\"emoji-name\">${name}</span></li>';\n\n/**\n * Match an @mention\n *\n * @param flag - The character sequence used to trigger this match (e.g. :).\n * @param subtext - The string to be tested.\n * @param shouldStartWithSpace - Should the pattern include a test for a whitespace prefix?\n * @returns Matching string if successful. Null on failure to match.\n */\nexport function matchAtMention(flag: string, subtext: string, shouldStartWithSpace: boolean): string | null {\n    const match = _matchAtMention(subtext, shouldStartWithSpace);\n    if (match) {\n        rawMatch = match.rawMatch;\n        return match.match;\n    }\n\n    return null;\n}\n\n/**\n * Custom matching for our emoji images. Eg. :) :/ >:(\n *\n * @param flag - The character sequence used to trigger this match (e.g. :).\n * @param subtext - The string to be tested.\n * @param shouldStartWithSpace - Should the pattern include a test for a whitespace prefix?\n * @returns Matching string if successful.  Null on failure to match.\n */\nexport function matchFakeEmoji(flag, subtext, shouldStartWithSpace) {\n    flag = flag.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, \"\\\\$&\");\n    if (shouldStartWithSpace) {\n        flag = \"(?:^|\\\\s)\" + flag;\n    }\n\n    // Some browsers append a linefeed to the end of subtext.  We need to allow for it.\n    const regexp = new RegExp(flag + \"([A-Za-z0-9_+-]*|[^\\\\x00-\\\\xff]*)(?:\\\\n)?$\", \"gi\");\n    const match = regexp.exec(subtext);\n\n    if (match) {\n        return match[2] || match[1];\n    } else {\n        return null;\n    }\n}\n\nexport function initializeAtComplete(editorElement, iframe?: HTMLIFrameElement) {\n    // Handle iframe situation\n    const iframeWindow = iframe ? iframe.contentWindow : \"\";\n\n    const remoteDataHandler = (query, callback) => {\n        // Do this because of undefined when adding spaces to\n        // matcher callback, as it will be monitoring changes.\n        query = query || \"\";\n\n        // Only all query strings greater than min_characters\n        if (query.length >= minCharacters) {\n            // If the cache array contains less than LIMIT 30\n            // (according to server logic), then there's no\n            // point sending another request to server, as there\n            // won't be any more results, as this is the maximum.\n            let shouldContinueFiltering = true;\n\n            // Remove last character so that the string can be\n            // found in the cache, if exists, then check if its\n            // matching array has less than the server limit of\n            // matches, which means there are no more, so save the\n            // additional server request from being sent.\n            let filterString = \"\";\n\n            // Loop through string and find first closest match in\n            // the cache, and if a match, check if more filtering\n            // is required.\n            for (let i = 0, l = query.length; i < l; i++) {\n                filterString = query.slice(0, -i);\n\n                if (atCache[filterString] && atCache[filterString].length < serverLimit) {\n                    // Add this other query to empty array, so that it\n                    // will not fire off another request.\n                    atEmpty[query] = query;\n\n                    // Do not filter more, meaning, do not send\n                    // another server request, as all the necessary\n                    // data is already in memory.\n                    shouldContinueFiltering = false;\n                    break;\n                }\n            }\n\n            // Check if query would be empty, based on previously\n            // cached empty results. Compare against the start of\n            // the latest query string.\n            let isQueryEmpty = false;\n\n            // Loop through cache of empty query strings.\n            for (const key in atEmpty) {\n                if (atEmpty.hasOwnProperty(key)) {\n                    // See if cached empty results match the start\n                    // of the latest query. If so, then no point\n                    // sending new request, as it will return empty.\n                    if (query.match(new RegExp(\"^\" + key + \"+\")) !== null) {\n                        isQueryEmpty = true;\n                        break;\n                    }\n                }\n            }\n\n            const filterSuccessHandler = data => {\n                if (Array.isArray(data)) {\n                    data.forEach(result => {\n                        if (typeof result === \"object\" && typeof result.name === \"string\") {\n                            // Convert special characters to safely insert into template.\n                            result.name = result.name\n                                .replace(/&/g, \"&amp;\")\n                                .replace(/</g, \"&lt;\")\n                                .replace(/>/g, \"&gt;\")\n                                .replace(/\"/g, \"&quot;\")\n                                .replace(/'/g, \"&apos;\");\n                        }\n                    });\n                }\n\n                callback(data);\n\n                // If data is empty, cache the results to prevent\n                // other requests against similarly-started\n                // query strings.\n                if (data.length) {\n                    atCache[query] = data;\n                } else {\n                    atEmpty[query] = query;\n                }\n            };\n\n            // Produce the suggestions based on data either\n            // cached or retrieved.\n            if (shouldContinueFiltering && !isQueryEmpty && !atCache[query]) {\n                $.getJSON(\n                    formatUrl(\"/user/tagsearch\"),\n                    {\n                        q: query,\n                        limit: serverLimit,\n                    },\n                    filterSuccessHandler,\n                );\n            } else {\n                // If no point filtering more as the parent filter\n                // has not been maxed out with responses, use the\n                // closest parent filter instead of the latest\n                // query string.\n                if (!shouldContinueFiltering) {\n                    callback(atCache[filterString]);\n                } else {\n                    callback(atCache[query]);\n                }\n            }\n        }\n    };\n\n    /**\n     * Pre-insert handler for atwho.\n     *\n     * Note, in contenteditable mode (iframe for us), the value is surrounded by span tags.\n     */\n    function beforeInsertHandler(value: string, $li: JQuery<any>): string {\n        // It's better to use the value provided, as it may have\n        // html tags around it, depending on mode. Using the\n        // regular expression avoids the need to check what mode\n        // the suggestion is made in, and then constructing\n        // it based on that. Optional assignment for undefined\n        // matcher callback results.\n        let username = $li.data(\"value\") || \"\";\n        // Pop off the flag--usually @ or :\n        username = username.slice(1, username.length);\n\n        // Check if there are any whitespaces, and if so, add\n        // quotation marks around the whole name.\n        const requiresQuotation = /[^\\w-]/.test(username);\n\n        // Check if there are already quotation marks around\n        // the string--double or single.\n        const hasQuotation = /([\"'])(.+)([\"'])/g.test(username);\n\n        let insert = username;\n        if (requiresQuotation && !hasQuotation) {\n            // Do not even need to have value wrapped in\n            // any tags at all. It will be done automatically.\n            // insert = value.replace(/(.*\\>?)@([\\w\\d\\s\\-\\+\\_]+)(\\<?.*)/, '$1@\"$2\"$3');\n            insert = '\"' + username + '\"';\n        }\n\n        // This is needed for checking quotation mark directly\n        // after at character, and preventing another at character\n        // from being inserted into the page.\n        const rawAtMatch = rawMatch || \"\";\n\n        const atQuote = /.?@([\"'])/.test(rawAtMatch);\n\n        // If atQuote is false, then insert the at character,\n        // otherwise it means the user typed a quotation mark\n        // directly after the at character, which, would get\n        // inserted again if not checked. atQuote would\n        // be false most of the time; the exception is when\n        // it's true.\n        if (!atQuote) {\n            insert = this.at + insert;\n        }\n\n        // The last character prevents the matcher from trigger on nearly everything.\n        return insert;\n    }\n\n    /**\n     * Custom highlighting to accept spaces in names.\n     * This is almost a copy of the default in the library, with tweaks in the regex.\n     */\n    function highlightHandler(li: string, query: string): string {\n        if (!query) {\n            return li;\n        }\n        const regexp = new RegExp(\">\\\\s*(\\\\w*)(\" + query.replace(\"+\", \"\\\\+\") + \")(\\\\w*)\\\\s*(\\\\s+.+)?<\", \"ig\");\n        // Capture group 4 for possible spaces\n        return li.replace(regexp, (str, $1, $2, $3, $4) => {\n            // Weird Chrome behaviour, so check for undefined, then\n            // set to empty string if so.\n            if (typeof $3 === \"undefined\") {\n                $3 = \"\";\n            }\n            if (typeof $4 === \"undefined\") {\n                $4 = \"\";\n            }\n\n            return \"> \" + $1 + \"<strong>\" + $2 + \"</strong>\" + $3 + $4 + \" <\";\n        });\n    }\n\n    $(editorElement)\n        .atwho({\n            at: \"@\",\n            tpl: '<li data-value=\"@${name}\" data-id=\"${id}\">${name}</li>',\n            limit: maxSuggestions,\n            callbacks: {\n                remote_filter: remoteDataHandler,\n                before_insert: beforeInsertHandler,\n                highlighter: highlightHandler,\n                matcher: matchAtMention,\n            },\n            cWindow: iframeWindow,\n        })\n        .atwho({\n            at: \":\",\n            tpl: emojiTemplate,\n            insert_tpl: \"${atwho-data-value}\",\n            callbacks: {\n                matcher: matchFakeEmoji,\n                tplEval: (tpl, map) => log(map),\n            },\n            limit: maxSuggestions,\n            data: emojiList,\n            cWindow: iframeWindow,\n        });\n\n    /**\n     * This hook is triggered when atWho places a selection list in the window.\n     * The context is passed implicitly when triggered by at.js.\n     *\n     * @param event - A custom event triggered by the advanced editor iframe/wysiwyg.\n     * @param offset - The pixel offsets inside of the iframe.\n     * @param context - Context from the contenteditable inside of the iframe.\n     */\n    function iframeAtWhoRepositionHandler(event: any, offset: any, context: any) {\n        // Actual suggestion box that will appear.\n        const suggestionElement = context.view.$el;\n\n        // The area where text will be typed (contenteditable body).\n        const $inputor = context.$inputor;\n\n        // Display it below the text.\n        const lineHeight = parseInt($inputor.css(\"line-height\"), 10);\n\n        // offset contains the top left values of the offset to the iframe\n        // we need to convert that to main window coordinates\n        const iframeOffset = $(iframe).offset();\n        let leftCoordinate = (iframeOffset ? iframeOffset.left : 0) + offset.left;\n        let topCoordinate = iframeOffset ? iframeOffset.top : 0;\n        let selectHeight = 0;\n\n        // In wysiwyg mode, the suggestbox follows the typing, which\n        // does not happen in regular mode, so adjust it.\n        // Either @ or : for now.\n        const at = context.at;\n        const { text } = context.query;\n        const fontMirror = $(\".BodyBox,.js-bodybox\");\n        const font = fontMirror.css(\"font-size\") + \" \" + fontMirror.css(\"font-family\");\n\n        // Get font width\n        const fontWidth = (at + text).width(font) - 2;\n\n        if (at === \"@\") {\n            leftCoordinate -= fontWidth;\n        }\n\n        if (at === \":\") {\n            leftCoordinate -= 2;\n        }\n\n        // atWho adds 3 select areas, presumably for differnet positing on screen (above below etc)\n        // This finds the active one and gets the container height\n        $(suggestionElement).each((index, element) => {\n            const outerHeight = $(element).outerHeight();\n            const height = $(element).height();\n\n            if (outerHeight && height && outerHeight > 0) {\n                selectHeight += height + lineHeight;\n            }\n        });\n\n        // Now should we show the selection box above or below?\n        const windowHeight = $(window).height() || 0;\n        const scrollPosition = $(window).scrollTop() || 0;\n        const selectionPosition = topCoordinate + offset.top - ($(window).scrollTop() || 0);\n        const iAvailableSpace = windowHeight - (selectionPosition - scrollPosition);\n\n        if (iAvailableSpace >= selectHeight) {\n            // Enough space below\n            topCoordinate = topCoordinate + offset.top + selectHeight - scrollPosition;\n        } else {\n            // Place it above instead\n            // @todo should check if this is more space than below\n            topCoordinate = topCoordinate + offset.top - scrollPosition;\n        }\n\n        // Move the select box\n        const newOffset = {\n            left: leftCoordinate,\n            top: topCoordinate,\n        };\n        $(suggestionElement).offset(newOffset);\n    }\n\n    // Only necessary for iframe.\n    // Based on work here: https://github.com/ichord/At.js/issues/124\n    if (iframeWindow) {\n        $(iframeWindow).on(\"reposition.atwho\", iframeAtWhoRepositionHandler);\n    }\n}\n","/**\n * Set wepback's public path.\n * Otherwise the lookups of dynamically imported webpack files can fail on sites that have a different webroot\n * Eg. installed in a subfolder / using Reverse Proxy.\n *\n * @author Adam Charron <adam.c@vanillaforums.com>\n * @copyright 2009-2018 Vanilla Forums Inc.\n * @license http://www.opensource.org/licenses/gpl-2.0.php GNU GPL v2\n */\n\nconst potentialPublicPath = window.gdn && window.gdn.meta && window.gdn.meta.WebRoot;\nconst finalPublicPath = potentialPublicPath != null ? potentialPublicPath : \"/\";\n\n/**\n * This needs to be a free variable.\n *\n * Webpack does some magic to make this work.\n * It you try and set a local or global version of it, it WILL NOT work.\n *\n * @see https://stackoverflow.com/questions/12934929/what-are-free-variables\n * @see https://webpack.js.org/configuration/output/#output-publicpath\n * @see https://github.com/webpack/webpack/issues/2776#issuecomment-233208623\n */\n// @ts-ignore: Cannot find variable warning. See comment aboe.\n__webpack_public_path__ = finalPublicPath;\n","/**\n * General utility functions.\n * This file should have NO external dependencies other than javascript.\n *\n * @copyright 2009-2018 Vanilla Forums Inc.\n * @license https://opensource.org/licenses/GPL-2.0 GPL-2.0\n */\n\n/**\n * @type {boolean} The current debug setting.\n * @private\n */\nlet _debug = false;\n\n/**\n * Get or set the debug flag.\n *\n * @param newValue - The new value of debug.\n * @returns the current debug setting.\n */\nexport function debug(newValue?: boolean): boolean {\n    if (newValue !== undefined) {\n        _debug = newValue;\n    }\n\n    return _debug;\n}\n\ntype NormalCallback = (...args: any[]) => any;\ntype PromiseCallback = (...args: any[]) => Promise<any>;\n\nexport type PromiseOrNormalCallback = NormalCallback | PromiseCallback;\n\n/**\n * Resolve an array of functions that return promises sequentially.\n *\n * @param promiseFunctions - The functions to execute.\n *\n * @returns An array of all results in sequential order.\n *\n * @example\n * const urls = ['/url1', '/url2', '/url3']\n * const functions = urls.map(url => () => fetch(url))\n * resolvePromisesSequentially(funcs)\n *   .then(console.log)\n *   .catch(console.error)\n */\nexport function resolvePromisesSequentially(promiseFunctions: PromiseOrNormalCallback[]): Promise<any[]> {\n    if (!Array.isArray(promiseFunctions)) {\n        throw new Error(\"First argument needs to be an array of Promises\");\n    }\n\n    return new Promise((resolve, reject) => {\n        let count = 0;\n        let results = [];\n\n        function iterationFunction(previousPromise, currentPromise) {\n            return previousPromise\n                .then(result => {\n                    if (count++ !== 0) {\n                        results = results.concat(result);\n                    }\n\n                    return currentPromise(result, results, count);\n                })\n                .catch(err => reject(err));\n        }\n\n        promiseFunctions = promiseFunctions.concat(() => Promise.resolve());\n\n        promiseFunctions.reduce(iterationFunction, Promise.resolve(false)).then(() => {\n            resolve(results);\n        });\n    });\n}\n\n/**\n * Log something to console.\n *\n * This only prints in debug mode.\n *\n * @param value - The value to log.\n */\nexport function log(...value: any[]) {\n    if (_debug) {\n        // tslint:disable-next-line:no-console\n        console.log(...value);\n    }\n}\n\n/**\n * Log an error to console.\n *\n * @param value - The value to log.\n */\nexport function logError(...value: any[]) {\n    // tslint:disable-next-line:no-console\n    console.error(...value);\n}\n\n/**\n * Log a warning to console.\n *\n * @param value - The value to log.\n */\nexport function logWarning(...value: any[]) {\n    // tslint:disable-next-line:no-console\n    console.warn(...value);\n}\n\n/**\n * A simple, fast method of hashing a string. Similar to Java's hash function.\n * https://stackoverflow.com/a/7616484/1486603\n *\n * @param str - The string to hash.\n *\n * @returns The hash code returned.\n */\nexport function hashString(str: string): number {\n    function hashReduce(prevHash, currVal) {\n        // tslint:disable-next-line:no-bitwise\n        return (prevHash << 5) - prevHash + currVal.charCodeAt(0);\n    }\n    return str.split(\"\").reduce(hashReduce, 0);\n}\n\n/**\n * Split a string in multiple pieces similar to String.prototype.split but ignore most acccent characters.\n *\n * This will still return pieces with accents.\n *\n * @param toSplit The string to split.\n * @param splitWith The string to split with.\n */\nexport function splitStringLoosely(toSplit: string, splitWith: string): string[] {\n    const normalizedName = toSplit.normalize(\"NFD\").replace(/[\\u0300-\\u036f]/g, \"\");\n    const normalizedSplitTerm = splitWith.normalize(\"NFD\").replace(/[\\u0300-\\u036f]/g, \"\");\n    const normalizedPieces = normalizedName.split(new RegExp(`(${normalizedSplitTerm})`, \"i\"));\n\n    let charactersUsed = 0;\n    return normalizedPieces.map(piece => {\n        const start = charactersUsed;\n        charactersUsed += piece.length;\n        return toSplit.substring(start, charactersUsed);\n    });\n}\n\ninterface IClass {\n    new (): any;\n}\n\nexport function isInstanceOfOneOf(needle: any, haystack: IClass[]) {\n    for (const classItem of haystack) {\n        if (needle instanceof classItem) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\nexport function simplifyFraction(numerator: number, denominator: number) {\n    const findGCD = (a, b) => {\n        return b ? findGCD(b, a % b) : a;\n    };\n    const gcd = findGCD(numerator, denominator);\n\n    numerator = numerator / gcd;\n    denominator = denominator / gcd;\n\n    return {\n        numerator,\n        denominator,\n        shorthand: denominator + \":\" + numerator,\n    };\n}\n\ninterface IMentionMatch {\n    match: string;\n    rawMatch: string;\n}\n\n/**\n * Custom matching to allow quotation marks in the matching string as well as spaces.\n * Spaces make things more complicated.\n *\n * @param subtext - The string to be tested.\n * @param shouldStartWithSpace - Should the pattern include a test for a whitespace prefix?\n * @returns Matching string if successful.  Null on failure to match.\n */\nexport function matchAtMention(\n    subtext: string,\n    shouldStartWithSpace: boolean = false,\n    requireQuotesForWhitespace: boolean = true,\n): IMentionMatch | null {\n    // Split the string at the lines to allow for a simpler regex.\n    const lines = subtext.split(\"\\n\");\n    const lastLine = lines[lines.length - 1];\n\n    // If you change this you MUST change the regex in src/scripts/__tests__/legacy.test.js !!!\n    /**\n     * Put together the non-excluded characters.\n     *\n     * @param {boolean} excludeWhiteSpace - Whether or not to exclude whitespace characters.\n     *\n     * @returns {string} A Regex string.\n     */\n    function nonExcludedCharacters(excludeWhiteSpace) {\n        let excluded =\n            \"[^\" +\n            '\"' + // Quote character\n            \"\\\\u0000-\\\\u001f\\\\u007f-\\\\u009f\" + // Control characters\n            \"\\\\u2028\"; // Line terminator\n\n        if (excludeWhiteSpace) {\n            excluded += \"\\\\s\";\n        }\n\n        excluded += \"]\";\n        return excluded;\n    }\n\n    let regexStr =\n        \"@\" + // @ Symbol triggers the match\n        \"(\" +\n        // One or more non-greedy characters that aren't excluded. Whitespace is allowed, but a starting quote is required.\n        '\"(' +\n        nonExcludedCharacters(false) +\n        '+?)\"?' +\n        \"|\" + // Or\n        // One or more non-greedy characters that aren't exluded. Whitespace may be excluded.\n        \"(\" +\n        nonExcludedCharacters(requireQuotesForWhitespace) +\n        '+?)\"?' +\n        \")\" +\n        \"(?:\\\\n|$)\"; // Newline terminates.\n\n    // Determined by at.who library\n    if (shouldStartWithSpace) {\n        regexStr = \"(?:^|\\\\s)\" + regexStr;\n    }\n    const regex = new RegExp(regexStr, \"gi\");\n    const match = regex.exec(lastLine);\n    if (match) {\n        return {\n            rawMatch: match[0],\n            match: match[2] || match[1], // Return either of the matching groups (quoted or unquoted).\n        };\n    }\n\n    // No match\n    return null;\n}\n\n/** This should mirror extensions allowed in Vanilla\\ImageResizer.php */\nconst IMAGE_REGEX = /^image\\/(gif|jpe?g|png)/i;\n\n/**\n * A filter for use with [].filter\n *\n * Matches only image image type files.\n * @private\n *\n * @param file - A File object.\n * @see https://developer.mozilla.org/en-US/docs/Web/API/File\n *\n * @returns Whether or not the file is an acceptable image\n */\nexport function isFileImage(file: File): boolean {\n    if (IMAGE_REGEX.test(file.type)) {\n        return true;\n    }\n\n    log(\"Filtered out non-image file: \", file.name);\n    return false;\n}\n\nexport function capitalizeFirstLetter(str: string): string {\n    return str.charAt(0).toUpperCase() + str.slice(1);\n}\n\n/**\n * Transform an array of objects and an map of objets with a given key.\n *\n * Objects that do not contain the given key are dropped.\n *\n * @param array The array to go through.\n * @param key The key to lookup.\n */\nexport function indexArrayByKey<T extends object>(\n    array: T[],\n    key: string,\n): {\n    [key: string]: T;\n} {\n    const object = {};\n    for (const item of array) {\n        if (key in item) {\n            if (!(item[key] in object)) {\n                object[item[key]] = [];\n            }\n            object[item[key]].push(item);\n        }\n    }\n    return object;\n}\n\nconst SAFE_PROTOCOL_REGEX = /^(http:\\/\\/|https:\\/\\/|tel:|mailto:\\/\\/)/;\n\n/**\n * Sanitize a URL to ensure that it matches a whitelist of approved url schemes. If the url does not match one of these schemes, prepend `unsafe:` before it.\n *\n * Allowed protocols\n * - \"http://\",\n * - \"https://\",\n * - \"tel:\",\n * - \"mailto://\",\n *\n * @param url The url to sanitize.\n */\nexport function sanitizeUrl(url: string) {\n    if (url.match(SAFE_PROTOCOL_REGEX)) {\n        return url;\n    } else {\n        return \"unsafe:\" + url;\n    }\n}\n","/**\n * @copyright 2009-2018 Vanilla Forums Inc.\n * @license https://opensource.org/licenses/GPL-2.0 GPL-2.0\n */\n\nexport const enum LoadStatus {\n    PENDING = \"PENDING\",\n    LOADING = \"LOADING\",\n    SUCCESS = \"SUCCESS\",\n    ERROR = \"ERROR\",\n}\n\ninterface IPendingValue {\n    status: LoadStatus.PENDING;\n}\n\ninterface ILoadingValue<T> {\n    status: LoadStatus.LOADING;\n    data?: T;\n    error?: IApiError;\n}\n\ninterface ISuccessValue<T> {\n    status: LoadStatus.SUCCESS;\n    data: T;\n    error?: undefined;\n}\n\ninterface IErrorValue<T> {\n    status: LoadStatus.ERROR;\n    error: IApiError;\n    data?: T;\n}\n\nexport type ILoadable<T> = IPendingValue | ILoadingValue<T> | ISuccessValue<T> | IErrorValue<T>;\n\nexport interface IApiResponse<DataType = any> {\n    data: DataType;\n    status: number;\n    headers: any;\n}\n\nexport interface IFieldError {\n    message: string; // translated message\n    code: string; // translation code\n    field: string;\n    status?: number; // HTTP status\n}\n\nexport interface IApiError {\n    message: string;\n    status: number;\n    errors?: {\n        [key: string]: IFieldError[];\n    };\n}\n","/**\n * @copyright 2009-2018 Vanilla Forums Inc.\n * @license https://opensource.org/licenses/GPL-2.0 GPL-2.0\n */\n\nimport { IUserFragment } from \"@dashboard/@types/api\";\n\nexport interface IUserAuthenticator {\n    authenticatorID: string;\n    type: string;\n    isUnique: boolean;\n    name: string;\n    ui: {\n        url: string;\n        buttonName: string;\n        photoUrl: string | null;\n        backgroundColor: string | null;\n        foregroundColor: string | null;\n    };\n    isUserLinked?: boolean;\n    sso?: any;\n}\n\nexport const enum AuthenticationStep {\n    AUTHENTICATED = \"authenticated\",\n    LINK_USER = \"linkUser\",\n}\n\nexport interface IAuthenticateResponse {\n    authenticationStep: AuthenticationStep;\n    user?: IUserFragment;\n    authSessionID?: string;\n    targetUrl?: string;\n}\n\nexport interface IAuthenticatePasswordParams {\n    username: string;\n    password: string;\n    persist?: boolean;\n}\n\nexport interface IAuthenticatePasswordResponseData extends IUserFragment {}\n","/**\n * A module to isolate meta data passed from the server into a single dependency.\n * This should always be used instead of accessing window.gdn directly.\n *\n * @copyright 2009-2018 Vanilla Forums Inc.\n * @license https://opensource.org/licenses/GPL-2.0 GPL-2.0\n */\n\ninterface IGdn {\n    meta: AnyObject;\n    permissions: AnyObject;\n    translations: AnyObject;\n    [key: string]: any;\n}\n\n/** The gdn object may be set in an inline script in the head of the document. */\nconst gdn = window.gdn || {};\n\nif (!(\"meta\" in gdn)) {\n    gdn.meta = {};\n}\n\nif (!(\"permissions\" in gdn)) {\n    gdn.permissions = {};\n}\n\nif (!(\"translations\" in gdn)) {\n    gdn.translations = {};\n}\n\nexport default gdn as IGdn;\n","/**\n * Entrypoint for the APIv2 calls. Prepulates an axios instance with some config settings.\n *\n * @copyright 2009-2018 Vanilla Forums Inc.\n * @license https://opensource.org/licenses/GPL-2.0 GPL-2.0\n */\n\nimport { formatUrl, t } from \"@dashboard/application\";\nimport { isFileImage, indexArrayByKey } from \"@dashboard/utility\";\nimport axios from \"axios\";\nimport qs from \"qs\";\nimport { IEmbedData } from \"@dashboard/embeds\";\nimport { IFieldError, LoadStatus, ILoadable } from \"@dashboard/@types/api\";\n\nfunction fieldErrorTransformer(responseData) {\n    if (responseData.status >= 400 && responseData.errors && responseData.errors.length > 0) {\n        responseData.errors = indexArrayByKey(responseData.errors, \"field\");\n    }\n\n    return responseData;\n}\n\nconst api = axios.create({\n    baseURL: formatUrl(\"/api/v2/\"),\n    headers: {\n        common: {\n            \"X-Requested-With\": \"vanilla\",\n        },\n    },\n    transformResponse: [...axios.defaults.transformResponse, fieldErrorTransformer],\n    paramsSerializer: params => qs.stringify(params, { indices: false }),\n});\n\nexport default api;\n\n/**\n * Upload an image using Vanilla's API v2.\n *\n * @param file - The file to upload.\n *\n * @throws If the file given is not an image. You must check yourself first.\n */\nexport async function uploadImage(image: File): Promise<IEmbedData> {\n    if (!isFileImage(image)) {\n        throw new Error(\n            `Unable to upload an image of type ${image.type}. Supported formats included .gif, .jpg and .png`,\n        );\n    }\n\n    const data = new FormData();\n    data.append(\"file\", image, image.name);\n    data.append(\"type\", \"image\");\n\n    const result = await api.post(\"/media\", data);\n    result.data.type = \"image\";\n    return result.data;\n}\n\n/**\n * Extract a field specific error from an ILoadable if applicable.\n *\n * @param loadable - The loadable to extract from.\n * @param field - The field to extract.\n *\n * @returns an array of IFieldErrors if found or undefined.\n */\nexport function getFieldErrors(loadable: ILoadable<any>, field: string): IFieldError[] | undefined {\n    if (loadable.status === LoadStatus.ERROR || loadable.status === LoadStatus.LOADING) {\n        if (loadable.error && loadable.error.errors && loadable.error.errors[field]) {\n            return loadable.error.errors[field];\n        }\n    }\n}\n\n/**\n * Extract a global error message out of an ILoadable if applicable.\n *\n * @param loadable - The loadable to extract from.\n * @param validFields - Field to check for overriding fields errors from. A global error only shows if there are no valid field errors.\n *\n * @returns A global error message or an undefined.\n */\nexport function getGlobalErrorMessage(loadable: ILoadable<any>, validFields: string[]): string | undefined {\n    if (loadable.status === LoadStatus.ERROR || loadable.status === LoadStatus.LOADING) {\n        for (const field of validFields) {\n            if (getFieldErrors(loadable, field)) {\n                return;\n            }\n        }\n\n        if (loadable.error) {\n            return loadable.error.message || t(\"An error has occurred, please try again.\");\n        }\n    }\n}\n","/**\n * Entrypoint for gradually replacing global.js\n *\n * At some point everything in this folder should be able to be removed (new base theme).\n *\n * @copyright 2009-2018 Vanilla Forums Inc.\n * @license https://opensource.org/licenses/GPL-2.0 GPL-2.0\n */\n\nimport { onContent, onReady } from \"@dashboard/application\";\nimport { initializeAtComplete } from \"@dashboard/legacy/atwho\";\n\n// Initialize legacy @mentions for all BodyBox elements.\nif ($.fn.atwho) {\n    onReady(() => initializeAtComplete(\".BodyBox,.js-bodybox\"));\n    onContent(() => initializeAtComplete(\".BodyBox,.js-bodybox\"));\n\n    // Also assign this function to the global `gdn` object.\n    // The advanced editor calls this function directly when in wysiwyg format, as it needs to\n    // handle an iframe, and the editor instance needs to be referenced. The advanced editor does not yet use\n    // this build process so it can only communicate through here with a global.\n    window.gdn.atCompleteInit = initializeAtComplete;\n}\n","/**\n * Primary bootstrapping of the frontend JS. This entrypoint should be the last once executed.\n *\n * @copyright 2009-2018 Vanilla Forums Inc.\n * @license https://opensource.org/licenses/GPL-2.0 GPL-2.0\n */\n\nimport { onContent, getMeta, _executeReady, _mountComponents } from \"@dashboard/application\";\nimport { log, logError, debug } from \"@dashboard/utility\";\nimport gdn from \"@dashboard/gdn\";\nimport apiv2 from \"@dashboard/apiv2\";\n\n// Right now this is imported here instead of being its own bundle.\n// Once we have some part of vanilla that can function without the legacy js,\n// this should be pulled out into its own javascript bundle.\nimport \"../legacy\";\n\n// Inject the debug flag into the utility.\ndebug(getMeta(\"debug\", false));\n\n// Export the API to the global object.\ngdn.apiv2 = apiv2;\n\nlog(\"Bootstrapping\");\n_executeReady()\n    .then(() => {\n        log(\"Bootstrapping complete.\");\n        // Mount all data-react components.\n        onContent(e => {\n            _mountComponents(e.target);\n        });\n\n        const contentEvent = new CustomEvent(\"X-DOMContentReady\", { bubbles: true, cancelable: false });\n        document.dispatchEvent(contentEvent);\n    })\n    .catch(error => {\n        logError(error);\n    });\n"],"sourceRoot":""}