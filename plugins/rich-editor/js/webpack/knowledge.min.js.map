{"version":3,"sources":["webpack://vanillaknowledge/./plugins/rich-editor/src/scripts/state/mention/mentionActions.ts","webpack://vanillaknowledge/./plugins/rich-editor/src/scripts/state/mention/MentionTrie.ts","webpack://vanillaknowledge/./plugins/rich-editor/src/scripts/state/mention/mentionReducer.ts","webpack://vanillaknowledge/./plugins/rich-editor/src/scripts/state/instance/instanceActions.ts","webpack://vanillaknowledge/./plugins/rich-editor/src/scripts/quill/blots/abstract/FocusableEmbedBlot.ts","webpack://vanillaknowledge/./plugins/rich-editor/src/scripts/quill/blots/blocks/BlockBlot.ts","webpack://vanillaknowledge/./plugins/rich-editor/src/scripts/quill/blots/blocks/CodeBlockBlot.ts","webpack://vanillaknowledge/./plugins/rich-editor/src/scripts/quill/utility.ts","webpack://vanillaknowledge/./plugins/rich-editor/src/scripts/state/instance/instanceReducer.ts","webpack://vanillaknowledge/./plugins/rich-editor/src/scripts/state/editorReducer.ts","webpack://vanillaknowledge/./plugins/rich-editor/src/scripts/entries/knowledge.ts","webpack://vanillaknowledge/./build/entries/public-path.ts"],"names":["SET_ACTIVE_SUGGESTION","LOAD_USERS_REQUEST","LOAD_USERS_FAILURE","LOAD_USERS_SUCCESS","MentionTrie","this","MAX_PARTIAL_LOOKUP_ITERATIONS","root","prototype","insert","word","value","current","i","length","letter","children","contents","getNode","node","undefined","char","charAt","getValue","getValueFromPartialsOfWord","x","Math","min","substring","potentialValue","initialState","lastSuccessfulUsername","currentUsername","usersTrie","mention_MentionTrie","activeSuggestionID","activeSuggestionIndex","CREATE_INSTANCE","SET_SELECTION","_super","FocusableEmbedBlot","domNode","_this","call","focusableElement","setAttribute","__extends","create","classList","add","scripts_embeds","remove","quill","Object","scripts_utility","hadFocus","document","activeElement","offset","scroll","update","core_default","a","sources","USER","potentialNewEmbedToFocus","getBlotAtIndex","focus","setSelection","insertNewlineAfter","parchment_default","insertInto","next","selfPosition","API","defineProperty","contains","childToFocus","querySelector","HTMLElement","Error","parentNode","find","tagName","className","blotName","block","BlockBlot","BlockBlot_extends","allowedChildren","__spread","block_default","CodeBlockBlot","CodeBlockBlot_extends","text_default","break_default","cursor_default","code_default","index","blotClass","condition","blot","descendant","MIN_MENTION_LENGTH","Map","defaultSelection","instanceReducer_initialState","defaultInstance","currentSelection","lastGoodSelection","mentionSelection","validateIDExistance","state","action","idExists","payload","editorID","type","state_editorReducer","redux","mentions","username","status","api","LOADING","shouldKeepPreviousResults","previousSuccessfulName","__assign","_a","error","ERROR","data","_b","users","SUCCESS","searchName","looseCollator","Intl","Collator","usage","sensitivity","ignorePunctuation","numeric","sort","userA","userB","name","includes","compare","sortSuggestions","firstUserID","domID","_c","suggestionID","suggestionIndex","instances","instanceReducer_assign","selection","instanceState","hasFocus","blotConstructor","range","getSelection","descendants","rangeContainsBlot","blocks_CodeBlockBlot","leafOffset","utility_read","getLeaf","leafContentBeforeCursor","getText","leafAtSignIndex","lastIndexOf","mentionIndex","potentialMention","getMentionRange","reducerRegistry","_library_application__WEBPACK_IMPORTED_MODULE_0__","__webpack_require__","p"],"mappings":"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","file":"/plugins/rich-editor/js/webpack/knowledge.min.js?cf9a434c9279cb39fb17","sourcesContent":["/**\n * @author Adam (charrondev) Charron <adam.c@vanillaforums.com>\n * @copyright 2009-2018 Vanilla Forums Inc.\n * @license GPL-2.0-only\n */\n\nimport { Dispatch } from \"redux\";\nimport { ActionsUnion, createAction } from \"@library/state/utility\";\nimport api from \"@library/apiv2\";\nimport { IMentionSuggestionData } from \"@rich-editor/components/toolbars/pieces/MentionSuggestion\";\nimport { IStoreState } from \"@rich-editor/@types/store\";\nimport { IApiError, LoadStatus } from \"@library/@types/api\";\n\nexport const SET_ACTIVE_SUGGESTION = \"[mentions] set active suggestion\";\nexport const LOAD_USERS_REQUEST = \"[mentions] load users request\";\nexport const LOAD_USERS_FAILURE = \"[mentions] load users failure\";\nexport const LOAD_USERS_SUCCESS = \"[mentions] load users success\";\n\n// The number of characters that we will lookup to try and invalidate a lookup early.\nconst USER_LIMIT = 50;\n\n/**\n * Filter users down to a list that loosely matches the current searchName\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Collator\n */\nexport function filterSuggestions(users: IMentionSuggestionData[], searchName: string) {\n    const searchCollator = Intl.Collator(\"en\", {\n        usage: \"search\",\n        sensitivity: \"base\",\n        ignorePunctuation: true,\n        numeric: true,\n    });\n\n    return users.filter((userSuggestion: IMentionSuggestionData) => {\n        if (userSuggestion.name.length < searchName.length) {\n            return false;\n        }\n\n        const suggestionNamePartial = userSuggestion.name.substring(0, searchName.length);\n        return searchCollator.compare(suggestionNamePartial, searchName) === 0;\n    });\n}\n\n// export function should;\n\n/**\n * Make an API request for mention suggestions. These results are cached by the lookup username.\n */\nfunction loadUsers(username: string) {\n    return (dispatch: Dispatch<any>, getState: () => IStoreState) => {\n        const { usersTrie } = getState().editor.mentions;\n\n        // Attempt an exact lookup first.\n        const exactLookup = usersTrie.getValue(username);\n        if (exactLookup != null) {\n            switch (exactLookup.status) {\n                case LoadStatus.SUCCESS:\n                    return dispatch(actions.loadUsersSuccess(username, exactLookup.data));\n                case LoadStatus.LOADING:\n                    // Already handled\n                    return;\n                case LoadStatus.ERROR:\n                    // Previously failed.\n                    dispatch(actions.loadUsersFailure(username, exactLookup.error));\n                    return;\n            }\n        }\n\n        // Attempt a partial lookup to try and see if we can get results without an API request\n        const partialLookup = usersTrie.getValueFromPartialsOfWord(username);\n        if (partialLookup != null) {\n            switch (partialLookup.status) {\n                case LoadStatus.SUCCESS: {\n                    if (partialLookup.data.length < USER_LIMIT) {\n                        // The previous match already found the maximum amount of users that the server had\n                        // Return the previous results.\n                        return dispatch(\n                            actions.loadUsersSuccess(username, filterSuggestions(partialLookup.data, username)),\n                        );\n                    }\n                }\n                case LoadStatus.ERROR:\n                // Previously failed. We still want to proceed to a real lookup so do nothing.\n                case LoadStatus.PENDING:\n                // We still want to proceed to a real lookup so do nothing.\n            }\n        }\n\n        // Start the lookup.\n        dispatch(actions.loadUsersRequest(username));\n\n        const params = {\n            name: username + \"*\",\n            order: \"mention\",\n            limit: USER_LIMIT,\n        };\n        return api\n            .get(\"/users/by-names/\", { params /*, cancelToken: this.apiCancelSource.token*/ })\n            .then(response => {\n                if (response.status >= 500) {\n                    throw new Error(response.data);\n                }\n\n                // Add unique domIDs to each user.\n                const users = response.data.map(data => {\n                    data.domID = \"mentionSuggestion\" + data.userID;\n                    return data;\n                });\n\n                // Result is good. Lets GO!\n                dispatch(actions.loadUsersSuccess(username, users));\n            })\n            .catch(error => {\n                dispatch(actions.loadUsersFailure(username, error));\n            });\n    };\n}\n\nexport const actions = {\n    loadUsersRequest: (username: string) => createAction(LOAD_USERS_REQUEST, { username }),\n    loadUsersFailure: (username: string, error: IApiError) => createAction(LOAD_USERS_FAILURE, { username, error }),\n    loadUsersSuccess: (username: string, users: IMentionSuggestionData[]) =>\n        createAction(LOAD_USERS_SUCCESS, { username, users }),\n    setActiveSuggestion: (suggestionID: string, suggestionIndex: number) =>\n        createAction(SET_ACTIVE_SUGGESTION, { suggestionID, suggestionIndex }),\n};\n\nexport const thunks = {\n    loadUsers,\n};\n\nexport type ActionTypes = ActionsUnion<typeof actions>;\n","/**\n * @author Adam (charrondev) Charron <adam.c@vanillaforums.com>\n * @copyright 2009-2018 Vanilla Forums Inc.\n * @license GPL-2.0-only\n */\n\nimport { IMentionSuggestionData } from \"@rich-editor/components/toolbars/pieces/MentionSuggestion\";\nimport { ILoadable } from \"@library/@types/api\";\n\nexport type IMentionValue = ILoadable<IMentionSuggestionData[]>;\n\nexport interface IMentionNode {\n    children?: {\n        [key: string]: IMentionNode;\n    };\n    value?: IMentionValue;\n}\n\n/**\n * A trie for storage of mention data.\n */\nexport default class MentionTrie {\n    public MAX_PARTIAL_LOOKUP_ITERATIONS = 10;\n    private root: IMentionNode = {};\n\n    /**\n     * Insert a value into a node for the word. This will overwrite whatever value the node already has\n     *\n     * @param word - The location in the trie.\n     * @param value - The value for the node.\n     */\n    public insert(word: string, value: IMentionValue): void {\n        let current = this.root;\n\n        for (let i = 0; i < word.length; i++) {\n            const letter = word[i];\n            if (!current.children) {\n                current.children = {};\n            }\n\n            if (!(letter in current.children)) {\n                const contents: IMentionNode = i !== word.length - 1 ? {} : { children: {} };\n                current.children[letter] = contents;\n            }\n\n            current = current.children[letter];\n        }\n\n        current.value = value;\n    }\n\n    /**\n     * Get a node for a given word.\n     *\n     * If no word is passed the root node will be returned.\n     *\n     * @param word - The word to lookup.\n     */\n    public getNode(word?: string): IMentionNode | null {\n        let node = this.root;\n        if (word === undefined) {\n            return node;\n        }\n\n        for (let i = 0; i < word.length; i++) {\n            const char = word.charAt(i);\n            if (node.children && node.children[char]) {\n                node = node.children[char];\n            } else {\n                return null;\n            }\n        }\n        return node;\n    }\n\n    /**\n     * Get the value out of a particular node.\n     *\n     * @param word - The word to lookup.\n     */\n    public getValue(word: string): IMentionValue | null {\n        const node = this.getNode(word);\n        return (node && node.value) || null;\n    }\n\n    /**\n     * Lookup the value for a word using increasingly small substrings of the current string.\n     *\n     * Number of iterations is capped at MAX_PARTIAL_LOOKUP_ITERATIONS.\n     *\n     * ex. this.getValueFormPartials(\"test\") will lookup for\n     * - \"test\",\n     * - \"tes\",\n     * - \"te\",\n     * - \"t\"\n     *\n     * And return immediately if it finds a result.\n     */\n    public getValueFromPartialsOfWord(word: string): IMentionValue | null {\n        const startingLength = Math.min(this.MAX_PARTIAL_LOOKUP_ITERATIONS, word.length);\n        for (let x = startingLength; x > 0; x--) {\n            const substring = word.substring(0, x);\n            const potentialValue = this.getValue(substring);\n            if (potentialValue != null) {\n                return potentialValue;\n            }\n        }\n\n        return null;\n    }\n}\n","/**\n * @author Adam (charrondev) Charron <adam.c@vanillaforums.com>\n * @copyright 2009-2018 Vanilla Forums Inc.\n * @license GPL-2.0-only\n */\n\nimport * as mentionActions from \"@rich-editor/state/mention/mentionActions\";\nimport MentionTrie from \"@rich-editor/state/mention/MentionTrie\";\nimport { IMentionSuggestionData } from \"@rich-editor/components/toolbars/pieces/MentionSuggestion\";\nimport { IMentionState } from \"@rich-editor/@types/store\";\nimport { LoadStatus } from \"@library/@types/api\";\n\nexport const initialState: IMentionState = {\n    lastSuccessfulUsername: null,\n    currentUsername: null,\n    usersTrie: new MentionTrie(),\n    activeSuggestionID: \"\",\n    activeSuggestionIndex: 0,\n};\n\nexport function sortSuggestions(users: IMentionSuggestionData[], searchName: string) {\n    const looseCollator = Intl.Collator(\"en\", {\n        usage: \"sort\",\n        sensitivity: \"variant\",\n        ignorePunctuation: true,\n        numeric: true,\n    });\n\n    return users.sort((userA, userB) => {\n        //  Return exact matches first.\n        if (userA.name.includes(searchName) && !userB.name.includes(searchName)) {\n            return -1;\n        }\n\n        if (userB.name.includes(searchName) && !userA.name.includes(searchName)) {\n            return 1;\n        }\n\n        // Then do a loose sort.\n        return looseCollator.compare(userA.name, userB.name);\n    });\n}\n\nexport default function mentionReducer(state = initialState, action: mentionActions.ActionTypes): IMentionState {\n    switch (action.type) {\n        case mentionActions.LOAD_USERS_REQUEST: {\n            const { username } = action.payload;\n            state.usersTrie.insert(username, {\n                status: LoadStatus.LOADING,\n            });\n\n            // We want to invalidate the previous results unless:\n            // - The new string is longer than the old one\n            // - The new string is a superset of the old one.\n            let shouldKeepPreviousResults = false;\n            const previousSuccessfulName = state.lastSuccessfulUsername;\n            if (previousSuccessfulName != null && username.length >= previousSuccessfulName.length) {\n                const newNameSubstring = username.substring(0, previousSuccessfulName.length);\n                if (newNameSubstring === previousSuccessfulName) {\n                    shouldKeepPreviousResults = true;\n                }\n            }\n\n            return {\n                ...state,\n                currentUsername: username,\n                lastSuccessfulUsername: shouldKeepPreviousResults ? state.lastSuccessfulUsername : null,\n            };\n        }\n        case mentionActions.LOAD_USERS_FAILURE: {\n            const { username, error } = action.payload;\n            state.usersTrie.insert(username, {\n                status: LoadStatus.ERROR,\n                data: undefined,\n                error,\n            });\n            return state;\n        }\n        case mentionActions.LOAD_USERS_SUCCESS: {\n            const { username, users } = action.payload;\n            state.usersTrie.insert(username, {\n                status: LoadStatus.SUCCESS,\n                data: sortSuggestions(users, username),\n            });\n\n            const firstUserID = users.length > 0 ? users[0].domID : \"\";\n            return {\n                ...state,\n                activeSuggestionID: firstUserID,\n                activeSuggestionIndex: 0,\n                lastSuccessfulUsername: username,\n                currentUsername: username === state.currentUsername ? null : state.currentUsername,\n            };\n        }\n        case mentionActions.SET_ACTIVE_SUGGESTION: {\n            const { suggestionID, suggestionIndex } = action.payload;\n            return {\n                ...state,\n                activeSuggestionID: suggestionID,\n                activeSuggestionIndex: suggestionIndex,\n            };\n        }\n        default:\n            return state;\n    }\n}\n","/**\n * @author Adam (charrondev) Charron <adam.c@vanillaforums.com>\n * @copyright 2009-2018 Vanilla Forums Inc.\n * @license GPL-2.0-only\n */\n\nimport { ActionsUnion, createAction } from \"@library/state/utility\";\nimport Quill, { RangeStatic } from \"quill/core\";\n\nexport const CREATE_INSTANCE = \"[instance] create\";\nexport const SET_SELECTION = \"[instance] set selection\";\nexport const CLEAR_MENTION_SELECTION = \"[instance] clear mention selection\";\n\nexport const actions = {\n    createInstance: (editorID: string | number) => createAction(CREATE_INSTANCE, { editorID }),\n    setSelection: (editorID: string | number, selection: RangeStatic | null, quill: Quill) =>\n        createAction(SET_SELECTION, { editorID, selection, quill }),\n};\n\nexport type ActionTypes = ActionsUnion<typeof actions>;\n","/**\n * @copyright 2009-2018 Vanilla Forums Inc.\n * @license GPL-2.0-only\n */\n\nimport Quill from \"quill/core\";\nimport { BlockEmbed } from \"quill/blots/block\";\nimport { FOCUS_CLASS } from \"@library/embeds\";\nimport { logWarning } from \"@library/utility\";\nimport Parchment from \"parchment\";\nimport { getBlotAtIndex } from \"@rich-editor/quill/utility\";\n\n/**\n * A blot that can take focus and still behave as part of the Quill editor.\n *\n * @see {EmbedFocusModule}\n */\nexport default class FocusableEmbedBlot extends BlockEmbed {\n    public static tagName = \"div\";\n    public static className = \"js-embed\";\n    public static blotName = \"embed-focusable\";\n\n    /**\n     * Create the basic HTML structure for the Blot.\n     */\n    public static create(value?: any) {\n        const node = super.create(value) as HTMLElement;\n        node.setAttribute(\"contenteditable\", false);\n        node.classList.add(FOCUS_CLASS);\n        return node;\n    }\n\n    public domNode: HTMLElement;\n\n    constructor(domNode) {\n        super(domNode);\n        this.focusableElement.setAttribute(\"tabindex\", -1);\n    }\n\n    /**\n     * In addition to removing the FocusableBlot, we either:\n     * - Place selection on another FocusableBlot that will be in the same spot as this one after deletion.\n     * - Place the selection back in quill where this blot was.\n     */\n    public remove() {\n        if (!this.quill) {\n            return logWarning(\"Attempted to focus a an embed blot that has not been mounted yet.\");\n        }\n\n        const hadFocus = this.focusableElement === document.activeElement;\n        const offset = this.offset(this.quill.scroll);\n        super.remove();\n        this.quill.update(Quill.sources.USER);\n\n        // If the blot had focus before the removal we need to place the focus either on quill and set the selection\n        // To the blot that will take this ones place, or focus another FocusableBlot coming in.\n        if (hadFocus) {\n            const potentialNewEmbedToFocus = getBlotAtIndex(this.quill, offset, FocusableEmbedBlot);\n            if (potentialNewEmbedToFocus) {\n                potentialNewEmbedToFocus.focus();\n            } else {\n                this.quill.setSelection(offset, 0, Quill.sources.USER);\n            }\n        }\n    }\n\n    /**\n     * Inserts a newline after this blot and places the cursor there.\n     */\n    public insertNewlineAfter() {\n        if (!this.quill) {\n            return logWarning(\"Attempted to focus a an embed blot that has not been mounted yet.\");\n        }\n\n        const newBlot = Parchment.create(\"block\", \"\");\n        newBlot.insertInto(this.quill.scroll, this.next);\n        this.quill.update(Quill.sources.USER);\n        this.quill.setSelection(this.offset() + 1, 0, Quill.sources.USER);\n    }\n\n    /**\n     * Focus this blot and set quill's selection to where it is.\n     *\n     * The actual act of focusing this blot will cause quill to set it's internal selection to null, but this will still fire out the change anyways. Many of our own listeners cache the last valid selection, and null is not a valid selection.\n     */\n    public focus() {\n        if (!this.quill) {\n            return logWarning(\"Attempted to focus a an embed blot that has not been mounted yet.\");\n        }\n\n        const selfPosition = this.offset(this.scroll);\n        this.quill.setSelection(selfPosition, 0, Quill.sources.API);\n        this.focusableElement.focus();\n    }\n\n    /**\n     * Get the focusable element inside of this blot. This is not necessarily the one we set here in child nodes. It will be whatever gets the FOCUS_CLASS.\n     */\n    private get focusableElement(): HTMLElement {\n        if (this.domNode.classList.contains(FOCUS_CLASS)) {\n            return this.domNode;\n        } else {\n            const childToFocus = this.domNode.querySelector(\".\" + FOCUS_CLASS);\n            if (childToFocus instanceof HTMLElement) {\n                return childToFocus;\n            } else {\n                throw new Error(\n                    \"Attempting to focus a DOM Node that either does not exist or is not an HTMLElement.\" +\n                        childToFocus,\n                );\n            }\n        }\n    }\n\n    /**\n     * Get the attached quill instance.\n     *\n     * This will _NOT_ work before attach() is called.\n     */\n    protected get quill(): Quill | null {\n        if (!this.scroll || !this.scroll.domNode.parentNode) {\n            return null;\n        }\n\n        return Quill.find(this.scroll.domNode.parentNode!);\n    }\n}\n","/**\n * @author Adam (charrondev) Charron <adam.c@vanillaforums.com>\n * @copyright 2009-2018 Vanilla Forums Inc.\n * @license GPL-2.0-only\n */\n\nimport Block from \"quill/blots/block\";\n\nexport default class BlockBlot extends Block {\n    public static allowedChildren = [...Block.allowedChildren];\n}\n","/**\n * @author Adam (charrondev) Charron <adam.c@vanillaforums.com>\n * @copyright 2009-2018 Vanilla Forums Inc.\n * @license GPL-2.0-only\n */\n\nimport CodeBlock from \"quill/formats/code\";\nimport Text from \"quill/blots/text\";\nimport Break from \"quill/blots/break\";\nimport Cursor from \"quill/blots/cursor\";\n\nexport default class CodeBlockBlot extends CodeBlock {\n    public static blotName = \"codeBlock\";\n    public static tagName = \"code\";\n    public static className = \"codeBlock\";\n    public static allowedChildren = [Text, Break, Cursor];\n\n    public static create(value) {\n        const domNode = super.create(value) as HTMLElement;\n        domNode.setAttribute(\"spellcheck\", false);\n        domNode.classList.add(\"code\");\n        domNode.classList.add(\"codeBlock\");\n        return domNode;\n    }\n}\n","/**\n * @author Adam (charrondev) Charron <adam.c@vanillaforums.com>\n * @copyright 2009-2018 Vanilla Forums Inc.\n * @license GPL-2.0-only\n */\n\nimport Emitter from \"quill/core/emitter\";\nimport Quill, { RangeStatic, Blot } from \"quill/core\";\nimport KeyboardModule from \"quill/modules/keyboard\";\nimport Delta from \"quill-delta\";\nimport { matchAtMention } from \"@library/utility\";\nimport uniqueId from \"lodash/uniqueId\";\nimport FocusableEmbedBlot from \"@rich-editor/quill/blots/abstract/FocusableEmbedBlot\";\nimport BlockBlot from \"@rich-editor/quill/blots/blocks/BlockBlot\";\nimport CodeBlockBlot from \"@rich-editor/quill/blots/blocks/CodeBlockBlot\";\n\ninterface IBoundary {\n    start: number;\n    end: number;\n}\n\n/**\n * Convert a range to start/end from index/length.\n *\n * @param range - The range to convert.\n *\n * @returns The converted boundary.\n */\nexport function convertRangeToBoundary(range?: RangeStatic): IBoundary | undefined {\n    if (!range) {\n        return;\n    }\n\n    return {\n        start: range.index,\n        end: range.index + range.length - 1,\n    };\n}\n\n/**\n * Convert a boundary into a range.\n *\n * @param boundary - The boundary to convert.\n *\n * @returns The converted range.\n */\nexport function convertBoundaryToRange(boundary?: IBoundary): RangeStatic | undefined {\n    if (!boundary) {\n        return;\n    }\n\n    return {\n        index: boundary.start,\n        length: boundary.end - boundary.start + 1,\n    };\n}\n\n/**\n * Extend a quill range backwards and forwards to the start/end of sub-ranges.\n *\n * @param range - The range to expand.\n * @param startRange - The range to extend the beginning with.\n * @param endRange - The range to extend the end with.\n *\n * @returns The expanded range.\n */\nexport function expandRange(\n    range: RangeStatic,\n    startRange?: RangeStatic,\n    endRange?: RangeStatic,\n): RangeStatic | undefined {\n    // Convert everything to start/end instead of index/length.\n    const boundary = convertRangeToBoundary(range);\n    const startBoundary = convertRangeToBoundary(startRange);\n    const endBoundary = convertRangeToBoundary(endRange);\n\n    if (boundary && startBoundary && startBoundary.start < boundary.start) {\n        boundary.start = startBoundary.start;\n    }\n\n    if (boundary && endBoundary && endBoundary.end > boundary.end) {\n        boundary.end = endBoundary.end;\n    }\n\n    return convertBoundaryToRange(boundary);\n}\n\n/**\n * Check if a given range contains a blot of a certain type. Could be more than one.\n *\n * @param quill - A quill instance.\n * @param range - The range to check.\n * @param blotConstructor - A class constructor for a blot.\n */\nexport function rangeContainsBlot(quill: Quill, blotConstructor: any, range: RangeStatic | null = null): boolean {\n    if (range === null) {\n        range = quill.getSelection();\n    }\n\n    if (!range) {\n        return false;\n    }\n\n    if (range.length > 0) {\n        const blots = quill.scroll.descendants(blotConstructor, range.index, range.length);\n        return blots.length > 0;\n    } else {\n        const blot = quill.scroll.descendant(blotConstructor, range.index)[0];\n        return !!blot;\n    }\n}\n\n/**\n * Format (or unformat) all blots in a given range. Will fully unformat a link even if the link is not entirely\n * inside of the current selection.\n *\n * @param quill - A quill instance.\n * @param range - The range to check.\n * @param blotConstructor - A class constructor for a blot.\n */\nexport function disableAllBlotsInRange<T extends Blot>(\n    quill: Quill,\n    blotConstructor:\n        | {\n              new (): T;\n          }\n        | typeof Blot,\n    range: RangeStatic | null = null,\n) {\n    if (range === null) {\n        range = quill.getSelection()!;\n    }\n\n    const currentBlots = quill.scroll.descendants(blotConstructor as any, range.index, range.length) as Blot[];\n    const firstBlot = currentBlots[0];\n    const lastBlot = currentBlots[currentBlots.length - 1];\n\n    const startRange = firstBlot && {\n        index: firstBlot.offset(quill.scroll),\n        length: firstBlot.length(),\n    };\n\n    const endRange = lastBlot && {\n        index: lastBlot.offset(quill.scroll),\n        length: lastBlot.length(),\n    };\n    const finalRange = expandRange(range, startRange, endRange);\n\n    if (finalRange) {\n        quill.formatText(finalRange.index, finalRange.length, \"link\", false, Emitter.sources.USER);\n    }\n}\n\n/**\n * Determine if a Blot is the first Blot in the scroll (or first through descendant blots).\n *\n * @example Both of the following are valid.\n *\n * Scroll -> Blot\n * Scroll -> Container -> Container -> Container -> Blot\n *\n * @param blot - the blot to check.\n * @param quill - Your quill instance.\n *\n * @returns Whether or not the blot is in the first position.\n */\nexport function isBlotFirstInScroll(blot: Blot, quill: Quill) {\n    const isFirstBlotInBlot = (childBlot, parentBlot) => {\n        // Bail out if there are not more children.\n        if (!parentBlot.children || !parentBlot.children.head) {\n            return false;\n        }\n\n        // We found our match.\n        if (childBlot === parentBlot.children.head) {\n            return true;\n        }\n\n        // Recurse through children.\n        return isFirstBlotInBlot(childBlot, parentBlot.children.head);\n    };\n\n    return isFirstBlotInBlot(blot, quill.scroll);\n}\n\n/**\n * Strips the formatting from the first blot in your quill instance.\n *\n * @param quill - Your quill instance\n */\nexport function stripFormattingFromFirstBlot(quill: Quill) {\n    const [firstBlot] = quill.getLine(0);\n    const blotName = (firstBlot.constructor as any).blotName;\n\n    const delta = new Delta().retain(firstBlot.length(), { [blotName]: false });\n    quill.updateContents(delta, Emitter.sources.USER);\n}\n\n/**\n * Normalize blots to what we consider a top level block.\n *\n * @param blot - The blot to normalize.\n *\n * Currently this means:\n * - LineBlot -> WrapperBlot\n */\nexport function normalizeBlotIntoBlock(blot: Blot): Blot {\n    if ((blot as any).getWrapper) {\n        return (blot as any).getWrapper(true);\n    } else {\n        return blot;\n    }\n}\n\n/**\n * Insert a new line at the end of the current Blot and trim excess newlines.\n *\n * @param range - The range that was altered.\n * @param deleteAmount - The amount of lines to trim.\n */\nexport function insertNewLineAfterBlotAndTrim(quill, range: RangeStatic, deleteAmount = 1) {\n    const [line, offset] = quill.getLine(range.index);\n\n    const newBlot = new BlockBlot(BlockBlot.create(\"\"));\n    const thisBlot = line;\n\n    const nextBlot = thisBlot.next;\n    newBlot.insertInto(quill.scroll, nextBlot);\n\n    // Now we need to clean up that extra newline.\n    const positionUpToPreviousNewline = range.index + line.length() - offset;\n    const deleteDelta = new Delta().retain(positionUpToPreviousNewline - deleteAmount).delete(deleteAmount);\n    quill.updateContents(deleteDelta, Emitter.sources.USER);\n    quill.setSelection(positionUpToPreviousNewline - deleteAmount, Emitter.sources.USER);\n}\n\n/**\n * Insert a newline at the end of the scroll. This is done through a delta like this because otherwise it gets optimized away :(\n *\n * @param quill - The quill instance.\n */\nexport function insertNewLineAtEndOfScroll(quill: Quill) {\n    const newLineBlot = new BlockBlot(BlockBlot.create(\"\"));\n    quill.scroll.appendChild(newLineBlot);\n    quill.update(Quill.sources.USER);\n    quill.setSelection(quill.scroll.length(), 0);\n}\n\n/**\n * Insert a newline at the start of the scroll. This is done through a delta like this because otherwise it gets optimized away :(\n *\n * @param quill - The quill instance.\n */\nexport function insertNewLineAtStartOfScroll(quill: Quill) {\n    const newLineBlot = new BlockBlot(BlockBlot.create(\"\"));\n    quill.scroll.insertBefore(newLineBlot, quill.scroll.children.head!);\n    quill.update(Quill.sources.USER);\n    quill.setSelection(0, 0);\n}\n\n/**\n * Get a Blot at a given index.\n *\n * @param quill - The Quill instance.\n * @param index - The index to look at.\n * @param blotClass - Optionally a blot class to filter by.\n */\nexport function getBlotAtIndex<T extends Blot>(\n    quill: Quill,\n    index: number,\n    blotClass?: { new (value?: any): T },\n): T | null {\n    const condition = blotClass ? blot => blot instanceof blotClass : blot => true;\n    return quill.scroll.descendant(condition, index)[0] as T;\n}\n\nconst MIN_MENTION_LENGTH = 1;\n\n/**\n * Get the range of text to convert to a mention.\n *\n * @param quill - A quill instance.\n * @param currentSelection - The current quill selection.\n *\n * @returns A range if a mention was matched, or null if one was not.\n */\nexport function getMentionRange(quill: Quill, currentSelection: RangeStatic | null): RangeStatic | null {\n    if (!quill.hasFocus()) {\n        return null;\n    }\n\n    if (!currentSelection) {\n        return null;\n    }\n\n    if (currentSelection.length > 0) {\n        return null;\n    }\n\n    if (rangeContainsBlot(quill, CodeBlockBlot, currentSelection)) {\n        return null;\n    }\n\n    // Get details about our current leaf (likely a TextBlot).\n    // This breaks the text to search every time there is a different DOM Node. Eg. A format, link, line break.\n    const [leaf] = quill.getLeaf(currentSelection.index);\n    const leafOffset = leaf.offset(quill.scroll);\n    const length = currentSelection.index - leafOffset;\n    const leafContentBeforeCursor = quill.getText(leafOffset, length);\n\n    // See if the leaf's content contains an `@`.\n    const leafAtSignIndex = leafContentBeforeCursor.lastIndexOf(\"@\");\n    if (leafAtSignIndex === -1) {\n        return null;\n    }\n    const mentionIndex = leafOffset + leafAtSignIndex;\n    const potentialMention = leafContentBeforeCursor.substring(leafAtSignIndex);\n\n    const usernameLength = potentialMention.length - 1;\n    const meetsLengthRequirements = usernameLength >= MIN_MENTION_LENGTH;\n    if (!meetsLengthRequirements) {\n        return null;\n    }\n\n    const isValidMention = matchAtMention(potentialMention, false, false);\n    if (!isValidMention) {\n        return null;\n    }\n\n    return {\n        index: mentionIndex,\n        length: potentialMention.length,\n    };\n}\n\n/**\n * Register an keyboard listener for the escape key.\n *\n * @param root - The element to watch for the escape listener in.\n * @param returnElement - The element to return to when escape is pressed.\n */\nexport function createEditorFlyoutEscapeListener(\n    root: HTMLElement,\n    returnElement: HTMLElement,\n    callback: (event: KeyboardEvent) => void = () => {\n        return;\n    },\n) {\n    root.addEventListener(\"keydown\", (event: KeyboardEvent) => {\n        if (KeyboardModule.match(event, { key: KeyboardModule.keys.ESCAPE, shiftKey: false })) {\n            if (root.contains(document.activeElement)) {\n                event.preventDefault();\n                returnElement.focus();\n                callback(event);\n            }\n        }\n    });\n}\n\nconst quillIDMap: Map<Quill, string> = new Map();\n\n/**\n * Generate a unique ID for a quill instance and store it in a Map with that instance.\n *\n * This is useful for generating a string key for a given quill instance.\n *\n * @param quill The quill instance.\n */\nexport function getIDForQuill(quill: Quill) {\n    if (quillIDMap.has(quill)) {\n        return quillIDMap.get(quill);\n    } else {\n        quillIDMap.set(quill, uniqueId(\"editorInstance\"));\n        return getIDForQuill(quill);\n    }\n}\n\n/**\n * Insert a blot into a quill instance at a given index.\n *\n * Why does this need to exist?\n * - The built in `blot.insertAt` method doesn't let you insert a premade blot.\n * - We need to calculate this offset anyways.\n * - Our scope is narrower because we are inserting only at the top level, where a blot is always a block.\n *\n * @param quill - A Quill instance.\n * @param index - The index to insert at.\n * @param blot - A blot already created.\n */\nexport function insertBlockBlotAt(quill: Quill, index: number, blot: Blot) {\n    const line = quill.getLine(index)[0] as Blot;\n\n    // Splitting lines is relative to the line start, the scroll start, so we need to calculate the\n    // index within the blot to split at.\n    const lineOffset = line.offset(quill.scroll);\n    const ref = line.split(index - lineOffset);\n    line.parent.insertBefore(blot, ref || undefined);\n}\n\n/**\n * Determine if and Embed inside of this class is focused.\n */\nexport function isEmbedSelected(quill: Quill, selection?: RangeStatic | null) {\n    if (!selection) {\n        return false;\n    }\n    const potentialEmbedBlot = getBlotAtIndex(quill, selection.index, FocusableEmbedBlot);\n    return !!potentialEmbedBlot;\n}\n\nexport const SELECTION_UPDATE = \"[editor] force selection update\";\n\n/**\n * Force a selection update on all quill editors.\n */\nexport function forceSelectionUpdate() {\n    document.dispatchEvent(new CustomEvent(SELECTION_UPDATE));\n}\n","/**\n * @author Adam (charrondev) Charron <adam.c@vanillaforums.com>\n * @copyright 2009-2018 Vanilla Forums Inc.\n * @license GPL-2.0-only\n */\n\nimport * as instanceActions from \"@rich-editor/state/instance/instanceActions\";\nimport { IEditorInstanceState, IEditorInstance } from \"@rich-editor/@types/store\";\nimport { getMentionRange } from \"@rich-editor/quill/utility\";\n\nconst defaultSelection = {\n    index: 0,\n    length: 0,\n};\n\nexport const initialState: IEditorInstanceState = {};\nexport const defaultInstance: IEditorInstance = {\n    currentSelection: defaultSelection,\n    lastGoodSelection: defaultSelection,\n    mentionSelection: null,\n};\n\n/**\n * Validate that an particular editor ID has been created before certain actions are taken on it.\n */\nfunction validateIDExistance(state: IEditorInstanceState, action: instanceActions.ActionTypes) {\n    const idExists = state[action.payload.editorID];\n    if (action.type === instanceActions.CREATE_INSTANCE && idExists) {\n        throw new Error(`Failed to create editor instance with id ${action.payload.editorID}. Id already exists`);\n    }\n\n    if (action.type !== instanceActions.CREATE_INSTANCE && !idExists) {\n        throw new Error(\n            `Could not perform an action for editor ID ${\n                action.payload.editorID\n            } that doesn't exist. Be sure to create an instance first.`,\n        );\n    }\n}\n\nexport default function instanceReducer(\n    state = initialState,\n    action: instanceActions.ActionTypes,\n): IEditorInstanceState {\n    switch (action.type) {\n        case instanceActions.CREATE_INSTANCE: {\n            validateIDExistance(state, action);\n            return {\n                ...state,\n                [action.payload.editorID]: defaultInstance,\n            };\n        }\n        case instanceActions.SET_SELECTION: {\n            validateIDExistance(state, action);\n            const { selection, editorID, quill } = action.payload;\n            const instanceState = state[editorID];\n            const { lastGoodSelection } = instanceState;\n\n            return {\n                ...state,\n                [editorID]: {\n                    ...instanceState,\n                    currentSelection: selection,\n                    lastGoodSelection: selection !== null ? selection : lastGoodSelection,\n                    mentionSelection: getMentionRange(quill, selection),\n                },\n            };\n        }\n        default: {\n            return state;\n        }\n    }\n}\n","/**\n * @author Adam (charrondev) Charron <adam.c@vanillaforums.com>\n * @copyright 2009-2018 Vanilla Forums Inc.\n * @license GPL-2.0-only\n */\n\nimport mentionReducer from \"@rich-editor/state/mention/mentionReducer\";\nimport instanceReducer from \"@rich-editor/state/instance/instanceReducer\";\nimport { combineReducers } from \"redux\";\n\nconst editorReducer = combineReducers({\n    mentions: mentionReducer,\n    instances: instanceReducer,\n});\n\nexport default editorReducer;\n","/*\n * @author Adam (charrondev) Charron <adam.c@vanillaforums.com>\n * @copyright 2009-2018 Vanilla Forums Inc.\n * @license https://opensource.org/licenses/GPL-2.0 GPL-2.0\n */\n\nimport { registerReducer } from \"@library/state/reducerRegistry\";\nimport editorReducer from \"@rich-editor/state/editorReducer\";\n\nregisterReducer(\"editor\", editorReducer);\n","/**\n * Set wepback's public path.\n * Otherwise the lookups of dynamically imported webpack files can fail on sites that have a different webroot\n * Eg. installed in a subfolder / using Reverse Proxy.\n *\n * @author Adam Charron <adam.c@vanillaforums.com>\n * @copyright 2009-2018 Vanilla Forums Inc.\n * @license GPL-2.0-only\n */\n\nimport { assetUrl } from \"@library/application\";\n\n/**\n * This needs to be a free variable.\n *\n * Webpack does some magic to make this work.\n * It you try and set a local or global version of it, it WILL NOT work.\n *\n * @see https://stackoverflow.com/questions/12934929/what-are-free-variables\n * @see https://webpack.js.org/configuration/output/#output-publicpath\n * @see https://github.com/webpack/webpack/issues/2776#issuecomment-233208623\n */\n// @ts-ignore: Cannot find variable warning. See comment aboe.\n__webpack_public_path__ = assetUrl(\"/\");\n"],"sourceRoot":""}