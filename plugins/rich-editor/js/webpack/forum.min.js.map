{"version":3,"sources":["webpack:///./plugins/rich-editor/src/scripts/state/editorReducer.ts","webpack:///./plugins/rich-editor/src/scripts/state/mention/mentionReducer.ts","webpack:///./plugins/rich-editor/src/scripts/state/mention/MentionTrie.ts","webpack:///./plugins/rich-editor/src/scripts/state/instance/instanceReducer.ts","webpack:///./plugins/rich-editor/src/scripts/entries/forum.ts","webpack:///./build/entries/public-path.ts","webpack:///./plugins/rich-editor/src/scripts/state/mention/mentionActions.ts","webpack:///./plugins/rich-editor/src/scripts/state/instance/instanceActions.ts"],"names":["editorReducer","Object","redux__WEBPACK_IMPORTED_MODULE_2__","mentions","_mention_mentionReducer__WEBPACK_IMPORTED_MODULE_0__","instances","_instance_instanceReducer__WEBPACK_IMPORTED_MODULE_1__","__webpack_exports__","initialState","lastSuccessfulUsername","currentUsername","usersTrie","_rich_editor_state_mention_MentionTrie__WEBPACK_IMPORTED_MODULE_1__","activeSuggestionID","activeSuggestionIndex","sortSuggestions","users","searchName","looseCollator","Intl","Collator","usage","sensitivity","ignorePunctuation","numeric","sort","userA","userB","name","includes","compare","mentionReducer","state","action","type","_mentionActions__WEBPACK_IMPORTED_MODULE_0__","username","payload","insert","status","shouldKeepPreviousResults","previousSuccessfulName","length","substring","__assign","_a","error","_b","firstUserID","domID","_c","suggestionID","suggestionIndex","MentionTrie","this","MAX_PARTIAL_LOOKUP_ITERATIONS","root","prototype","word","value","current","i","letter","children","contents","getNode","node","undefined","char","charAt","getValue","getValueFromPartialsOfWord","x","Math","min","potentialValue","defaultSelection","index","defaultInstance","currentSelection","lastGoodSelection","validateIDExistance","idExists","editorID","_instanceActions__WEBPACK_IMPORTED_MODULE_0__","Error","instanceReducer","selection","instanceState","setupEditor","discussionFormContainer","document","querySelectorAll","Promise","all","__webpack_require__","e","then","bind","mountEditor","sent","forEach","default","setupCommentEditForm","addEventListener","event","__awaiter","_this","container","target","Element","richEditor","querySelector","_dashboard_application__WEBPACK_IMPORTED_MODULE_2__","_dashboard_state_reducerRegistry__WEBPACK_IMPORTED_MODULE_0__","_rich_editor_state_editorReducer__WEBPACK_IMPORTED_MODULE_1__","potentialPublicPath","window","gdn","meta","WebRoot","finalPublicPath","p","SET_ACTIVE_SUGGESTION","LOAD_USERS_REQUEST","LOAD_USERS_FAILURE","LOAD_USERS_SUCCESS","USER_LIMIT","filterSuggestions","searchCollator","filter","userSuggestion","suggestionNamePartial","loadUsers","dispatch","getState","editor","exactLookup","actions","loadUsersSuccess","loadUsersFailure","partialLookup","loadUsersRequest","params","order","limit","_dashboard_apiv2__WEBPACK_IMPORTED_MODULE_1__","get","response","data","map","userID","catch","_dashboard_state_utility__WEBPACK_IMPORTED_MODULE_0__","setActiveSuggestion","thunks","CREATE_INSTANCE","SET_SELECTION","createInstance","setSelection"],"mappings":"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","file":"/plugins/rich-editor/js/webpack/forum.min.js","sourcesContent":["/**\n * @author Adam (charrondev) Charron <adam.c@vanillaforums.com>\n * @copyright 2009-2018 Vanilla Forums Inc.\n * @license https://opensource.org/licenses/GPL-2.0 GPL-2.0\n */\n\nimport mentionReducer from \"./mention/mentionReducer\";\nimport instanceReducer from \"./instance/instanceReducer\";\nimport { combineReducers } from \"redux\";\n\nconst editorReducer = combineReducers({\n    mentions: mentionReducer,\n    instances: instanceReducer,\n});\n\nexport default editorReducer;\n","/**\n * @author Adam (charrondev) Charron <adam.c@vanillaforums.com>\n * @copyright 2009-2018 Vanilla Forums Inc.\n * @license https://opensource.org/licenses/GPL-2.0 GPL-2.0\n */\n\nimport * as mentionActions from \"./mentionActions\";\nimport MentionTrie from \"@rich-editor/state/mention/MentionTrie\";\nimport { IMentionSuggestionData } from \"@rich-editor/components/toolbars/pieces/MentionSuggestion\";\nimport { IMentionState } from \"@rich-editor/@types/store\";\n\nexport const initialState: IMentionState = {\n    lastSuccessfulUsername: null,\n    currentUsername: null,\n    usersTrie: new MentionTrie(),\n    activeSuggestionID: \"\",\n    activeSuggestionIndex: 0,\n};\n\nexport function sortSuggestions(users: IMentionSuggestionData[], searchName: string) {\n    const looseCollator = Intl.Collator(\"en\", {\n        usage: \"sort\",\n        sensitivity: \"variant\",\n        ignorePunctuation: true,\n        numeric: true,\n    });\n\n    return users.sort((userA, userB) => {\n        //  Return exact matches first.\n        if (userA.name.includes(searchName) && !userB.name.includes(searchName)) {\n            return -1;\n        }\n\n        if (userB.name.includes(searchName) && !userA.name.includes(searchName)) {\n            return 1;\n        }\n\n        // Then do a loose sort.\n        return looseCollator.compare(userA.name, userB.name);\n    });\n}\n\nexport default function mentionReducer(state = initialState, action: mentionActions.ActionTypes): IMentionState {\n    switch (action.type) {\n        case mentionActions.LOAD_USERS_REQUEST: {\n            const { username } = action.payload;\n            state.usersTrie.insert(username, {\n                status: \"PENDING\",\n            });\n\n            // We want to invalidate the previous results unless:\n            // - The new string is longer than the old one\n            // - The new string is a superset of the old one.\n            let shouldKeepPreviousResults = false;\n            const previousSuccessfulName = state.lastSuccessfulUsername;\n            if (previousSuccessfulName != null && username.length > previousSuccessfulName.length) {\n                const newNameSubstring = username.substring(0, previousSuccessfulName.length);\n                if (newNameSubstring === previousSuccessfulName) {\n                    shouldKeepPreviousResults = true;\n                }\n            }\n\n            return {\n                ...state,\n                currentUsername: username,\n                lastSuccessfulUsername: shouldKeepPreviousResults ? state.lastSuccessfulUsername : null,\n            };\n        }\n        case mentionActions.LOAD_USERS_FAILURE: {\n            const { username, error } = action.payload;\n            state.usersTrie.insert(username, {\n                status: \"FAILED\",\n                users: null,\n                error,\n            });\n            return state;\n        }\n        case mentionActions.LOAD_USERS_SUCCESS: {\n            const { username, users } = action.payload;\n            state.usersTrie.insert(username, {\n                status: \"SUCCESSFUL\",\n                users: sortSuggestions(users, username),\n            });\n\n            const firstUserID = users.length > 0 ? users[0].domID : \"\";\n            return {\n                ...state,\n                activeSuggestionID: firstUserID,\n                activeSuggestionIndex: 0,\n                lastSuccessfulUsername: username,\n                currentUsername: username === state.currentUsername ? null : state.currentUsername,\n            };\n        }\n        case mentionActions.SET_ACTIVE_SUGGESTION: {\n            const { suggestionID, suggestionIndex } = action.payload;\n            return {\n                ...state,\n                activeSuggestionID: suggestionID,\n                activeSuggestionIndex: suggestionIndex,\n            };\n        }\n        default:\n            return state;\n    }\n}\n","/**\n * @author Adam (charrondev) Charron <adam.c@vanillaforums.com>\n * @copyright 2009-2018 Vanilla Forums Inc.\n * @license https://opensource.org/licenses/GPL-2.0 GPL-2.0\n */\n\nimport { IMentionSuggestionData } from \"@rich-editor/components/toolbars/pieces/MentionSuggestion\";\n\ninterface ISuccessValue {\n    status: \"SUCCESSFUL\";\n    users: IMentionSuggestionData[];\n}\n\ninterface IFailureValue {\n    status: \"FAILED\";\n    users?: null;\n    error: Error;\n}\n\ninterface IPendingValue {\n    status: \"PENDING\";\n}\n\nexport type IMentionValue = ISuccessValue | IFailureValue | IPendingValue;\n\nexport interface IMentionNode {\n    children?: {\n        [key: string]: IMentionNode;\n    };\n    value?: IMentionValue;\n}\n\n/**\n * A trie for storage of mention data.\n */\nexport default class MentionTrie {\n    public MAX_PARTIAL_LOOKUP_ITERATIONS = 10;\n    private root: IMentionNode = {};\n\n    /**\n     * Insert a value into a node for the word. This will overwrite whatever value the node already has\n     *\n     * @param word - The location in the trie.\n     * @param value - The value for the node.\n     */\n    public insert(word: string, value: IMentionValue): void {\n        let current = this.root;\n\n        for (let i = 0; i < word.length; i++) {\n            const letter = word[i];\n            if (!current.children) {\n                current.children = {};\n            }\n\n            if (!(letter in current.children)) {\n                const contents: IMentionNode = i !== word.length - 1 ? {} : { children: {} };\n                current.children[letter] = contents;\n            }\n\n            current = current.children[letter];\n        }\n\n        current.value = value;\n    }\n\n    /**\n     * Get a node for a given word.\n     *\n     * If no word is passed the root node will be returned.\n     *\n     * @param word - The word to lookup.\n     */\n    public getNode(word?: string): IMentionNode | null {\n        let node = this.root;\n        if (word === undefined) {\n            return node;\n        }\n\n        for (let i = 0; i < word.length; i++) {\n            const char = word.charAt(i);\n            if (node.children && node.children[char]) {\n                node = node.children[char];\n            } else {\n                return null;\n            }\n        }\n        return node;\n    }\n\n    /**\n     * Get the value out of a particular node.\n     *\n     * @param word - The word to lookup.\n     */\n    public getValue(word: string): IMentionValue | null {\n        const node = this.getNode(word);\n        return (node && node.value) || null;\n    }\n\n    /**\n     * Lookup the value for a word using increasingly small substrings of the current string.\n     *\n     * Number of iterations is capped at MAX_PARTIAL_LOOKUP_ITERATIONS.\n     *\n     * ex. this.getValueFormPartials(\"test\") will lookup for\n     * - \"test\",\n     * - \"tes\",\n     * - \"te\",\n     * - \"t\"\n     *\n     * And return immediately if it finds a result.\n     */\n    public getValueFromPartialsOfWord(word: string): IMentionValue | null {\n        const startingLength = Math.min(this.MAX_PARTIAL_LOOKUP_ITERATIONS, word.length);\n        for (let x = startingLength; x > 0; x--) {\n            const substring = word.substring(0, x);\n            const potentialValue = this.getValue(substring);\n            if (potentialValue != null) {\n                return potentialValue;\n            }\n        }\n\n        return null;\n    }\n}\n","/**\n * @author Adam (charrondev) Charron <adam.c@vanillaforums.com>\n * @copyright 2009-2018 Vanilla Forums Inc.\n * @license https://opensource.org/licenses/GPL-2.0 GPL-2.0\n */\n\nimport * as instanceActions from \"./instanceActions\";\nimport { IEditorInstanceState, IEditorInstance } from \"@rich-editor/@types/store\";\n\nconst defaultSelection = {\n    index: 0,\n    length: 0,\n};\n\nexport const initialState: IEditorInstanceState = {};\nexport const defaultInstance: IEditorInstance = {\n    currentSelection: defaultSelection,\n    lastGoodSelection: defaultSelection,\n};\n\n/**\n * Validate that an particular editor ID has been created before certain actions are taken on it.\n */\nfunction validateIDExistance(state: IEditorInstanceState, action: instanceActions.ActionTypes) {\n    const idExists = state[action.payload.editorID];\n    if (action.type === instanceActions.CREATE_INSTANCE && idExists) {\n        throw new Error(`Failed to create editor instance with id ${action.payload.editorID}. Id already exists`);\n    }\n\n    if (action.type !== instanceActions.CREATE_INSTANCE && !idExists) {\n        throw new Error(\n            `Could not perform an action for editor ID ${\n                action.payload.editorID\n            } that doesn't exist. Be sure to create an instance first.`,\n        );\n    }\n}\n\nexport default function instanceReducer(\n    state = initialState,\n    action: instanceActions.ActionTypes,\n): IEditorInstanceState {\n    switch (action.type) {\n        case instanceActions.CREATE_INSTANCE: {\n            validateIDExistance(state, action);\n            return {\n                ...state,\n                [action.payload.editorID]: defaultInstance,\n            };\n        }\n        case instanceActions.SET_SELECTION: {\n            validateIDExistance(state, action);\n            const { selection, editorID } = action.payload;\n            const instanceState = state[editorID];\n            const { lastGoodSelection } = instanceState;\n            return {\n                ...state,\n                [editorID]: {\n                    ...instanceState,\n                    currentSelection: selection,\n                    lastGoodSelection: selection !== null ? selection : lastGoodSelection,\n                },\n            };\n        }\n        default: {\n            return state;\n        }\n    }\n}\n","/*\n * @author Adam (charrondev) Charron <adam.c@vanillaforums.com>\n * @copyright 2009-2018 Vanilla Forums Inc.\n * @license https://opensource.org/licenses/GPL-2.0 GPL-2.0\n */\n\nimport { registerReducer } from \"@dashboard/state/reducerRegistry\";\nimport editorReducer from \"@rich-editor/state/editorReducer\";\nimport { onReady } from \"@dashboard/application\";\n\nonReady(() => {\n    registerReducer(\"editor\", editorReducer);\n    void setupEditor();\n    void setupCommentEditForm();\n});\n\n/**\n * Set up the new discussion form if it exists.\n */\nasync function setupEditor() {\n    const discussionFormContainer = document.querySelectorAll(\".richEditor\");\n    if (discussionFormContainer.length > 0) {\n        const mountEditor = await import(/* webpackChunkName: \"plugins/rich-editor/js/chunks/mountEditor\" */ \"@rich-editor/mountEditor\");\n        discussionFormContainer.forEach(mountEditor.default);\n    }\n}\n\n/**\n * Set up the editor if the someone clicks edit on a form.\n */\nasync function setupCommentEditForm() {\n    document.addEventListener(\"X-EditCommentFormLoaded\", async event => {\n        const container = event.target;\n        if (!(container instanceof Element)) {\n            return;\n        }\n\n        const richEditor = container.querySelector(\".richEditor\");\n        if (richEditor) {\n            const mountEditor = await import(/* webpackChunkName: \"plugins/rich-editor/js/chunks/mountEditor\" */ \"@rich-editor/mountEditor\");\n            mountEditor.default(richEditor);\n        }\n    });\n}\n","/**\n * Set wepback's public path.\n * Otherwise the lookups of dynamically imported webpack files can fail on sites that have a different webroot\n * Eg. installed in a subfolder / using Reverse Proxy.\n *\n * @author Adam Charron <adam.c@vanillaforums.com>\n * @copyright 2009-2018 Vanilla Forums Inc.\n * @license http://www.opensource.org/licenses/gpl-2.0.php GNU GPL v2\n */\n\nconst potentialPublicPath = window.gdn && window.gdn.meta && window.gdn.meta.WebRoot;\nconst finalPublicPath = potentialPublicPath != null ? potentialPublicPath : \"/\";\n\n/**\n * This needs to be a free variable.\n *\n * Webpack does some magic to make this work.\n * It you try and set a local or global version of it, it WILL NOT work.\n *\n * @see https://stackoverflow.com/questions/12934929/what-are-free-variables\n * @see https://webpack.js.org/configuration/output/#output-publicpath\n * @see https://github.com/webpack/webpack/issues/2776#issuecomment-233208623\n */\n// @ts-ignore: Cannot find variable warning. See comment aboe.\n__webpack_public_path__ = finalPublicPath;\n","/**\n * @author Adam (charrondev) Charron <adam.c@vanillaforums.com>\n * @copyright 2009-2018 Vanilla Forums Inc.\n * @license https://opensource.org/licenses/GPL-2.0 GPL-2.0\n */\n\nimport { Dispatch } from \"redux\";\nimport { ActionsUnion, createAction } from \"@dashboard/state/utility\";\nimport api from \"@dashboard/apiv2\";\nimport { IMentionSuggestionData } from \"@rich-editor/components/toolbars/pieces/MentionSuggestion\";\nimport { IStoreState } from \"@rich-editor/@types/store\";\n\nexport const SET_ACTIVE_SUGGESTION = \"[mentions] set active suggestion\";\nexport const LOAD_USERS_REQUEST = \"[mentions] load users request\";\nexport const LOAD_USERS_FAILURE = \"[mentions] load users failure\";\nexport const LOAD_USERS_SUCCESS = \"[mentions] load users success\";\n\n// The number of characters that we will lookup to try and invalidate a lookup early.\nconst USER_LIMIT = 50;\n\n/**\n * Filter users down to a list that loosely matches the current searchName\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Collator\n */\nexport function filterSuggestions(users: IMentionSuggestionData[], searchName: string) {\n    const searchCollator = Intl.Collator(\"en\", {\n        usage: \"search\",\n        sensitivity: \"base\",\n        ignorePunctuation: true,\n        numeric: true,\n    });\n\n    return users.filter((userSuggestion: IMentionSuggestionData) => {\n        if (userSuggestion.name.length < searchName.length) {\n            return false;\n        }\n\n        const suggestionNamePartial = userSuggestion.name.substring(0, searchName.length);\n        return searchCollator.compare(suggestionNamePartial, searchName) === 0;\n    });\n}\n\n// export function should;\n\n/**\n * Make an API request for mention suggestions. These results are cached by the lookup username.\n */\nfunction loadUsers(username: string) {\n    return (dispatch: Dispatch<any>, getState: () => IStoreState) => {\n        const { usersTrie } = getState().editor.mentions;\n\n        // Attempt an exact lookup first.\n        const exactLookup = usersTrie.getValue(username);\n        if (exactLookup != null) {\n            switch (exactLookup.status) {\n                case \"SUCCESSFUL\":\n                    return dispatch(actions.loadUsersSuccess(username, exactLookup.users));\n                case \"PENDING\":\n                    // Already working on it.\n                    return;\n                case \"FAILED\":\n                    // Previously failed.\n                    return dispatch(actions.loadUsersFailure(username, exactLookup.error));\n            }\n        }\n\n        // Attempt a partial lookup to try and see if we can get results without an API request\n        const partialLookup = usersTrie.getValueFromPartialsOfWord(username);\n        if (partialLookup != null) {\n            switch (partialLookup.status) {\n                case \"SUCCESSFUL\": {\n                    if (partialLookup.users.length < USER_LIMIT) {\n                        // The previous match already found the maximum amount of users that the server had\n                        // Return the previous results.\n                        return dispatch(\n                            actions.loadUsersSuccess(username, filterSuggestions(partialLookup.users, username)),\n                        );\n                    }\n                }\n                case \"FAILED\":\n                // Previously failed. We still want to proceed to a real lookup so do nothing.\n                case \"PENDING\":\n                // We still want to proceed to a real lookup so do nothing.\n            }\n        }\n\n        // Start the lookup.\n        dispatch(actions.loadUsersRequest(username));\n\n        const params = {\n            name: username + \"*\",\n            order: \"mention\",\n            limit: USER_LIMIT,\n        };\n        return api\n            .get(\"/users/by-names/\", { params /*, cancelToken: this.apiCancelSource.token*/ })\n            .then(response => {\n                if (response.status >= 500) {\n                    throw new Error(response.data);\n                }\n\n                // Add unique domIDs to each user.\n                const users = response.data.map(data => {\n                    data.domID = \"mentionSuggestion\" + data.userID;\n                    return data;\n                });\n\n                // Result is good. Lets GO!\n                dispatch(actions.loadUsersSuccess(username, users));\n            })\n            .catch(error => dispatch(actions.loadUsersFailure(username, error)));\n    };\n}\n\nexport const actions = {\n    loadUsersRequest: (username: string) => createAction(LOAD_USERS_REQUEST, { username }),\n    loadUsersFailure: (username: string, error: Error) => createAction(LOAD_USERS_FAILURE, { username, error }),\n    loadUsersSuccess: (username: string, users: IMentionSuggestionData[]) =>\n        createAction(LOAD_USERS_SUCCESS, { username, users }),\n    setActiveSuggestion: (suggestionID: string, suggestionIndex: number) =>\n        createAction(SET_ACTIVE_SUGGESTION, { suggestionID, suggestionIndex }),\n};\n\nexport const thunks = {\n    loadUsers,\n};\n\nexport type ActionTypes = ActionsUnion<typeof actions>;\n","/**\n * @author Adam (charrondev) Charron <adam.c@vanillaforums.com>\n * @copyright 2009-2018 Vanilla Forums Inc.\n * @license https://opensource.org/licenses/GPL-2.0 GPL-2.0\n */\n\nimport { ActionsUnion, createAction } from \"@dashboard/state/utility\";\nimport { RangeStatic } from \"quill/core\";\n\nexport const CREATE_INSTANCE = \"[instance] create\";\nexport const SET_SELECTION = \"[instance] set selection\";\n\nexport const actions = {\n    createInstance: (editorID: string | number) => createAction(CREATE_INSTANCE, { editorID }),\n    setSelection: (editorID: string | number, selection: RangeStatic | null) =>\n        createAction(SET_SELECTION, { editorID, selection }),\n};\n\nexport type ActionTypes = ActionsUnion<typeof actions>;\n"],"sourceRoot":""}